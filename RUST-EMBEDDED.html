<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Rust programming for embedded systems</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Rust programming for embedded systems</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction-to-embedded-systems"
id="toc-introduction-to-embedded-systems"><span
class="toc-section-number">1</span> Introduction to embedded systems</a>
<ul>
<li><a href="#what-is-an-embedded-system"
id="toc-what-is-an-embedded-system"><span
class="toc-section-number">1.1</span> What is an embedded
system?</a></li>
<li><a href="#microcontroller-vs.-microprocessor"
id="toc-microcontroller-vs.-microprocessor"><span
class="toc-section-number">1.2</span> Microcontroller
vs. Microprocessor</a></li>
<li><a href="#microcontrollers-from-the-esp-family"
id="toc-microcontrollers-from-the-esp-family"><span
class="toc-section-number">1.3</span> Microcontrollers from the ESP
family</a></li>
<li><a href="#rust-in-the-context-of-embedded-systems"
id="toc-rust-in-the-context-of-embedded-systems"><span
class="toc-section-number">1.4</span> Rust in the context of embedded
systems</a></li>
<li><a href="#bare-metal-programming-vs.-rtos"
id="toc-bare-metal-programming-vs.-rtos"><span
class="toc-section-number">1.5</span> Bare-metal programming
vs. RTOS</a></li>
</ul></li>
<li><a href="#working-with-peripherals-and-drivers"
id="toc-working-with-peripherals-and-drivers"><span
class="toc-section-number">2</span> Working with peripherals and
drivers</a>
<ul>
<li><a href="#general-purpose-inputoutput-gpio"
id="toc-general-purpose-inputoutput-gpio"><span
class="toc-section-number">2.1</span> General Purpose Input/Output
(GPIO)</a></li>
<li><a href="#timers-and-counters" id="toc-timers-and-counters"><span
class="toc-section-number">2.2</span> Timers and Counters</a></li>
<li><a href="#pulse-width-modulation-pwm"
id="toc-pulse-width-modulation-pwm"><span
class="toc-section-number">2.3</span> Pulse Width Modulation
(PWM)</a></li>
<li><a
href="#analog-to-digital-converters-and-digital-to-analog-converters"
id="toc-analog-to-digital-converters-and-digital-to-analog-converters"><span
class="toc-section-number">2.4</span> Analog-to-Digital Converters and
Digital-to-Analog Converters</a></li>
<li><a href="#serial-communications"
id="toc-serial-communications"><span
class="toc-section-number">2.5</span> Serial communications</a></li>
<li><a href="#the-pin-interface" id="toc-the-pin-interface"><span
class="toc-section-number">2.6</span> The Pin Interface</a></li>
<li><a href="#polling-vs.-interrupts"
id="toc-polling-vs.-interrupts"><span
class="toc-section-number">2.7</span> Polling vs. interrupts</a></li>
</ul></li>
<li><a href="#gpio-std" id="toc-gpio-std"><span
class="toc-section-number">3</span> GPIO (std)</a></li>
<li><a href="#gpio-no-std" id="toc-gpio-no-std"><span
class="toc-section-number">4</span> GPIO (no-std)</a></li>
<li><a href="#adcs-std" id="toc-adcs-std"><span
class="toc-section-number">5</span> ADCs (std)</a></li>
<li><a href="#adcs-no-std" id="toc-adcs-no-std"><span
class="toc-section-number">6</span> ADCs (no-std)</a></li>
<li><a href="#programming-timers-counters-std"
id="toc-programming-timers-counters-std"><span
class="toc-section-number">7</span> Programming Timers &amp; Counters
(std)</a></li>
<li><a href="#programmingtimers-counters-no-std"
id="toc-programmingtimers-counters-no-std"><span
class="toc-section-number">8</span> ProgrammingTimers &amp; Counters
(no-std)</a></li>
<li><a href="#pwm-std" id="toc-pwm-std"><span
class="toc-section-number">9</span> PWM (std)</a></li>
<li><a href="#pwm-no-std" id="toc-pwm-no-std"><span
class="toc-section-number">10</span> PWM (no-std)</a></li>
<li><a href="#serial-communication-std"
id="toc-serial-communication-std"><span
class="toc-section-number">11</span> Serial Communication (std)</a></li>
<li><a href="#serial-communication-no-std"
id="toc-serial-communication-no-std"><span
class="toc-section-number">12</span> Serial Communication
(no-std)</a></li>
<li><a href="#iot-networking-services-std"
id="toc-iot-networking-services-std"><span
class="toc-section-number">13</span> IoT &amp; Networking Services
(std)</a></li>
<li><a href="#the-embassy-framework-no-std"
id="toc-the-embassy-framework-no-std"><span
class="toc-section-number">14</span> The Embassy Framework
(no-std)</a></li>
</ul>
</nav>
<h1 data-number="1" id="introduction-to-embedded-systems"><span
class="header-section-number">1</span> Introduction to embedded
systems</h1>
<h2 data-number="1.1" id="what-is-an-embedded-system"><span
class="header-section-number">1.1</span> What is an embedded
system?</h2>
<p>An embedded system is a specialized computing platform engineered to
carry out a dedicated function—often in real-time—under stringent
resource constraints such as limited memory, processing capacity, and
power consumption. Unlike general-purpose computers, which support a
broad range of user applications and are designed for high-level
interactivity, embedded systems are tightly integrated with the physical
environment they monitor or control. They typically rely on
microcontrollers or system-on-chip (SoC) solutions, where the CPU cores,
memory (Flash or EEPROM), and peripherals are packaged into a single
unit. These platforms focus on reliability, deterministic behavior, and
optimization for size, cost, and power efficiency.</p>
<h3 data-number="1.1.1" id="core-architectural-elements"><span
class="header-section-number">1.1.1</span> Core architectural
elements</h3>
<p>At the heart of an embedded system lies a microcontroller (e.g., ARM
Cortex-M, AVR, RISC-V), which executes firmware stored in non-volatile
memory. This firmware initializes hardware components, configures
communication interfaces, and runs the core application logic.
Peripheral circuits, such as analog-to-digital converters, pulse-width
modulators, digital I/O pins, and communication interfaces (SPI, I2C,
UART, CAN, USB), provide the link between the digital controller and
real-world signals. Additional custom hardware blocks may handle
specialized tasks—such as signal processing, security algorithms, or
power management—reducing the load on the CPU core and enabling strict
power budgets to be met. In more complex designs, an SoC might include
GPUs or hardware accelerators to handle demanding tasks like computer
vision or cryptographic functions.</p>
<h3 data-number="1.1.2" id="firmware-and-software-stack"><span
class="header-section-number">1.1.2</span> Firmware and software
stack</h3>
<p>The embedded software, often referred to as firmware, is developed in
low-level languages like C or C++, with assembly routines for
performance-critical sections. Depending on the required performance and
timing guarantees, the system may run on a bare-metal architecture (a
“super loop” model with interrupt-driven event handling) or under a
real-time operating system (RTOS). An RTOS offers deterministic task
scheduling, interrupt handling, and inter-task communication mechanisms
(e.g., queues, semaphores, mailboxes). Safety-critical industries, such
as automotive or medical, often require compliance with strict
development standards (e.g., ISO 26262, IEC 62304) and extensive testing
to ensure reliability and meet functional safety requirements.</p>
<h3 data-number="1.1.3" id="operational-flow-and-control"><span
class="header-section-number">1.1.3</span> Operational flow and
control</h3>
<p>Embedded systems typically follow a repetitive cycle of sensing,
processing, and actuating. Sensors measure physical variables—ranging
from temperature and pressure to acceleration and voltage—and provide
data through analog or digital interfaces. The microcontroller processes
this data, applies the relevant control or decision algorithms (like PID
loops or sensor fusion), and issues appropriate commands to actuators.
These actuators can include motors, solenoids, LEDs, or displays,
translating digital instructions back into the physical domain.
Time-critical operations often rely on interrupts and prioritize tasks,
ensuring that essential actions occur within defined latency bounds. In
higher-level designs, additional functionality like wireless
connectivity (Wi-Fi, Bluetooth, Zigbee) or internet connectivity
(Ethernet) is integrated, enabling remote monitoring, configuration, or
data offloading to cloud services.</p>
<h3 data-number="1.1.4" id="design-constraints-and-optimization"><span
class="header-section-number">1.1.4</span> Design constraints and
optimization</h3>
<p>Resource constraints are a defining characteristic of embedded
systems. Memory (RAM and Flash) is commonly in the order of tens to
hundreds of kilobytes in low-power MCUs, and CPU clock speeds may be
only a few megahertz to a few hundred megahertz. These limitations drive
careful optimization of program size, data structures, and algorithmic
complexity. Low power consumption is often paramount, especially in
battery-operated devices, leading to techniques like dynamic frequency
scaling, sleep modes, and peripheral power gating. Hardware design must
also meet rigorous cost targets, given that embedded products are
frequently manufactured in high volumes. Component selection is
scrutinized to balance functionality, performance, and price.
Additionally, mechanical form factors, thermal considerations, and
electromagnetic compatibility (EMC) constraints can significantly
influence PCB layout and overall system architecture.</p>
<h3 data-number="1.1.5" id="application-domains"><span
class="header-section-number">1.1.5</span> Application domains</h3>
<p>Embedded systems permeate nearly every modern industry. In automotive
applications, engine control units (ECUs) modulate fuel injection and
ignition timing, while advanced driver-assistance systems (ADAS) perform
sensor fusion from cameras, radar, and LiDAR. Consumer electronics
integrate various embedded subsystems for battery management, sensor
hubs, and user interface control. Industrial automation depends on
programmable logic controllers (PLCs) and robotics platforms that demand
real-time control loops, robust communication interfaces (like Modbus or
industrial Ethernet), and high reliability. Medical devices such as
pacemakers and insulin pumps rely on ultra-low-power operation and
fault-tolerant design, conforming to strict regulatory guidelines. Even
aerospace and defense systems employ embedded technologies under extreme
operational conditions, where failure is not an option.</p>
<h3 data-number="1.1.6" id="emerging-trends-and-future-directions"><span
class="header-section-number">1.1.6</span> Emerging trends and future
directions</h3>
<p>As processing capabilities converge with shrinking silicon
geometries, MCUs and SoCs are increasingly incorporating machine
learning accelerators and hardware cryptographic engines. This trend
facilitates on-device inference for edge AI use cases, where real-time
decisions must be made without reliance on cloud services. Connectivity
and security are also top priorities, leading to widespread adoption of
secure bootloaders, hardware security modules, and over-the-air update
mechanisms that protect devices against malicious tampering. Real-time
operating systems continue to evolve with more advanced scheduling
policies, integrated networking stacks, and modular frameworks, further
streamlining embedded software development. The Internet of Things (IoT)
illustrates how embedded devices can form extensive networks, processing
vast amounts of sensor data at the edge while leveraging the cloud for
analysis, reporting, and long-term storage.</p>
<h2 data-number="1.2" id="microcontroller-vs.-microprocessor"><span
class="header-section-number">1.2</span> Microcontroller
vs. Microprocessor</h2>
<p>When discussing the foundational components of embedded systems, the
terms <em>microcontroller</em> (MCU) and <em>microprocessor</em>
inevitably surface. Although both are types of integrated circuits
(ICs), they differ significantly in terms of integration, performance,
packaging, and target applications. At a high level, a microprocessor is
the computational core (CPU) often found in general-purpose computing
platforms, whereas a microcontroller is more specialized, encapsulating
a CPU with on-chip memory and peripheral interfaces—an arrangement that
is typically optimized for control-oriented tasks in
resource-constrained environments.</p>
<h3 data-number="1.2.1" id="microprocessors"><span
class="header-section-number">1.2.1</span> Microprocessors</h3>
<p>A microprocessor functions as the central processing unit (CPU) in a
system, executing instructions, performing arithmetic operations, and
managing logic tasks. Typically employed in desktop computers, laptops,
and servers, microprocessors are known for their ability to support
multitasking, handle large software stacks, and accommodate complex
operating systems. They often incorporate multiple cores running at high
clock speeds, which allows for parallel processing and significant
computational throughput. However, they rely on external components—most
notably RAM, ROM, and various input/output controllers—for storage and
interaction with peripheral devices. Because of their high-performance
design, microprocessors are well-suited for applications where
substantial computational power is paramount. They excel in scenarios
that demand flexibility, such as running full-scale operating systems,
performing complex data analytics, or managing multimedia tasks. This
level of capability comes with trade-offs in power consumption, cost,
and board space, making microprocessor-based solutions less ideal for
tightly integrated, low-power embedded applications.</p>
<h3 data-number="1.2.2" id="microcontrollers"><span
class="header-section-number">1.2.2</span> Microcontrollers</h3>
<p>In contrast to microprocessors, microcontrollers are specialized
integrated circuits that place an emphasis on direct interaction with
sensors, actuators, and other control elements. A microcontroller
typically includes not just the CPU core (akin to a simplified
microprocessor), but also on-chip program memory (Flash or ROM), data
memory (RAM), and peripheral interfaces (e.g., GPIO, timers, ADCs,
serial communication). This high degree of integration minimizes
external component requirements, enabling microcontrollers to operate
efficiently in environments with strict constraints on size, power, and
cost. By design, microcontrollers often feature single-core CPUs
operating at relatively modest clock speeds. Although they may not match
the raw computational horsepower of microprocessors, they excel at
handling dedicated, real-time control tasks with minimal overhead. Their
lower clock frequencies and reduced power draw are especially beneficial
in battery-powered or energy-sensitive applications, such as IoT nodes,
home appliances, and automotive control systems. Furthermore,
microcontrollers’ simplified architecture makes them easier to program,
which can expedite firmware development and streamline hardware-software
integration.</p>
<h3 data-number="1.2.3" id="system-on-chip-soc"><span
class="header-section-number">1.2.3</span> System on Chip (SoC)</h3>
<p>A System on Chip (SoC) extends the concept of integration even
further, combining a CPU (microprocessor or microcontroller-like core)
with multiple peripherals and specialized units into a single package.
In many cases, SoCs blur the lines between traditional microcontrollers
and microprocessors: 1. Microcontroller-Based SoCs are fundamentally
microcontrollers but incorporate higher clock speeds, additional memory,
and specialized hardware accelerators (e.g., for cryptography or signal
processing). Espressif’s ESP series, for instance, are labeled as SoCs,
yet they share many traits with conventional microcontrollers. 2.
Microprocessor-Based SoCs as seen in certain Intel or ARM-based
platforms, merge microprocessor cores with ancillary chipsets or
co-processors, providing a single-package solution typically without
integrated main memory. These solutions often target complex,
high-performance scenarios while seeking to reduce board footprint and
power consumption relative to a multi-chip configuration. SoCs may
include GPU cores, FPGA fabric, or other domain-specific accelerators
(e.g., AI/ML inference engines), thereby accommodating more
compute-intensive, feature-rich applications. This advanced integration
makes SoCs suitable for products that require both the control-centric
approach of a microcontroller and the processing capabilities of a
microprocessor—ultimately, bridging the gap between embedded control
tasks and higher-level data processing requirements.</p>
<p>Packaging Considerations The term <em>package</em> refers to the
protective housing surrounding the silicon die(s) of microcontrollers,
microprocessors, or SoCs. Packaging facilitates several crucial
functions: 1. Physical Protection: Shields the silicon from mechanical
damage, contamination, and environmental factors. 2. Thermal Management:
Helps dissipate heat generated by the IC to maintain stable operating
temperatures. 3. Connectivity: Provides pins, pads, or balls (depending
on package style) for electrical connections to the PCB or external
devices.</p>
<h3 data-number="1.2.4" id="memory-mapping"><span
class="header-section-number">1.2.4</span> Memory mapping</h3>
<p>Memory mapping assigns specific address ranges to various components
within a microcontroller system, including peripherals, code memory, and
data memory. This organization allows the processor core to interact
with different blocks by referencing their designated memory addresses.
For example, to retrieve sensor data from an Analog-to-Digital Converter
(ADC), the processor accesses the address range allocated to the ADC,
prompting it to transfer the data. Memory addresses are typically
represented in hexadecimal notation (e.g., 0x100). In practice, if the
processor needs to read the next instruction from code memory, it sends
a read request to an address like 0x100 within the designated range.
Similarly, to configure a timer peripheral, the processor writes data to
an address within the timer’s assigned range (e.g., 0x22F). This direct
addressing simplifies software development by allowing programmers to
control peripherals as if they were regular memory locations.</p>
<h3 data-number="1.2.5" id="application-memory-layout"><span
class="header-section-number">1.2.5</span> Application memory
layout</h3>
<p>When an embedded application is compiled and linked, the resulting
memory layout is organized into specific regions that correspond to
different parts of the program. The microcontroller utilizes two primary
types of memory: Flash and SRAM. Flash memory is non-volatile and stores
the static application image or executable code, retaining its contents
even when power is lost. SRAM, on the other hand, is volatile and holds
dynamic data generated during the application’s runtime, similar to a
computer’s main memory.</p>
<p>Upon powering up, the application image resides in Flash memory,
divided into three main regions: 1. .text: Contains all the program
code, including functions and the Interrupt Vector Table (IVT), which
maps interrupts to their corresponding Interrupt Service Routines
(ISRs). 2. .rodata: Stores read-only data such as constants used by the
application. 3. .data: Holds initialized global variables that the
program uses during execution.</p>
<p>During the startup sequence, the microcontroller initializes the SRAM
by loading the necessary data from Flash memory. This process involves
copying the .data region from Flash to SRAM and setting up the runtime
environment for the application. The organized memory layout ensures
that the processor can efficiently execute code and manage data,
facilitating reliable and predictable behavior of embedded
applications.</p>
<p>Understanding memory mapping and application memory layout is crucial
for effective embedded system development. Memory mapping enables the
processor to efficiently interact with various peripherals by assigning
specific address ranges, simplifying the control and data transfer
processes. Meanwhile, comprehending the application memory layout
ensures that code and data are organized optimally within the
microcontroller’s memory architecture.</p>
<h3 data-number="1.2.6" id="instruction-set-architecture-isa"><span
class="header-section-number">1.2.6</span> Instruction Set Architecture
(ISA)</h3>
<p>Processor architecture defines the fundamental design and
organization of a processor’s central processing unit (CPU). In the
embedded domain, popular architectures include ARM (Cortex-M
processors), RISC-V, and Xtensa. The selection of a processor
architecture by microcontroller manufacturers is influenced by factors
such as performance requirements, power efficiency, cost, and the
specific use case. At the core of a microcontroller is the CPU, which
executes application code and instructions based on its ISA. The ISA
serves as the hardware-software interface, defining the functions the
processor can perform, such as arithmetic operations and data storage.
Each ISA is unique to its architecture—examples include ARM, Intel x86,
Xtensa, and RISC-V—and consists of machine instructions that are
typically written in assembly language. High-level programming languages
like C or Rust are compiled into assembly code specific to the
processor’s ISA, requiring the compiler to be aware of the underlying
architecture to generate appropriate machine code.</p>
<h3 data-number="1.2.7" id="memory-architecture"><span
class="header-section-number">1.2.7</span> Memory Architecture</h3>
<p>Microcontrollers utilize two primary types of memory: code memory and
data memory. Code memory, usually implemented with non-volatile Flash
memory, stores the application code or instructions that are flashed to
the microcontroller. Data memory, typically using volatile SRAM, holds
the application data generated during runtime. Effective memory
architecture is crucial for organizing and connecting these memory types
to the processor core, as simultaneous access to both can lead to
contention. There are two main memory architectures: Von-Neumann and
Harvard. The Von-Neumann architecture uses a single bus for both code
and data memory, which can lead to resource contention but offers
simplicity. In contrast, the Harvard architecture employs separate buses
for code and data memory, enhancing performance by eliminating bus
contention and supporting higher efficiency, especially in pipelined
architectures. Modern implementations of the Harvard architecture often
feature read/write code memory, moving away from the traditional
read-only configurations.</p>
<h2 data-number="1.3" id="microcontrollers-from-the-esp-family"><span
class="header-section-number">1.3</span> Microcontrollers from the ESP
family</h2>
<p>ESP microcontrollers, developed by Espressif Systems, are renowned
for their versatility and widespread use in Internet of Things (IoT)
applications. The ESP (Espressif Systems’ Platform) family is
particularly distinguished by its integrated Wi-Fi capabilities, and in
some models, Bluetooth connectivity, making them ideal for connected
devices. The two most notable ESP microcontrollers are the ESP8266 and
the ESP32.</p>
<p>The ESP8266 was one of Espressif’s first microcontrollers to gain
significant popularity. It is celebrated for its built-in Wi-Fi
functionality, providing a cost-effective solution for connecting
devices to the Internet. The ESP8266 is equipped with a 32-bit RISC CPU
based on the Xtensa LX3 core architecture, offering a balance of
performance and efficiency suitable for a variety of embedded
applications.</p>
<p>Building on the success of the ESP8266, the ESP32 emerged as a more
powerful and feature-rich microcontroller. The ESP32 series not only
includes enhanced Wi-Fi capabilities but also incorporates Bluetooth
connectivity, optional dual-core processing, and a wider array of
peripherals. This makes the ESP32 suitable for more demanding
applications that require higher performance and greater connectivity
options. Additionally, ESP32 microcontrollers come with different core
architectures, including both Xtensa and the open-source RISC-V,
providing developers with greater flexibility in their designs.</p>
<p>Espressif Systems offers a comprehensive suite of System-on-Chip
(SoC) offerings tailored to diverse IoT applications, categorized into
several families:</p>
<ol type="1">
<li>ESP32 Series: Introduced in 2016 as a successor to the ESP8266, the
ESP32 is based on the Xtensa dual-core 32-bit LX6 processor. It supports
both Wi-Fi and Bluetooth 4.2, along with various I/O options, making it
suitable for a wide range of applications.</li>
<li>ESP32-Sx Series: Launched in 2020, the S-series features the more
recent Xtensa LX7 processor. These SoCs are available in single and
dual-core configurations and support Bluetooth 5.0, offering enhanced
performance and connectivity.</li>
<li>ESP32-Cx Series: Also emerging in 2020, the C-series incorporates
the open-source RISC-V processor. These microcontrollers come in
single-core and dual-core variants, supporting Bluetooth 5.0 and Wi-Fi
6, catering to applications requiring advanced connectivity and
processing power.</li>
<li>ESP32-Hx Series: Announced in 2021, the H-series builds on the
C-series by adding more connectivity options, including Thread and
Zigbee protocols, enhancing their suitability for complex IoT
networks.</li>
<li>ESP32-Px Series: The most recent addition, announced in 2024, the
P-series is RISC-V-based and targets AI applications. It offers
multi-core functionality with a dual-core RISC-V processor for
high-performance workloads and a single-core RISC-V for low-power
operations. Notably, the P-series does not incorporate connectivity
features, focusing instead on secure and high-efficiency use cases.</li>
</ol>
<p>These SoC offerings cater to the evolving needs of IoT development,
providing a spectrum of features from ultra-low-power performance to
advanced security measures. Espressif also provides various development
kits and boards, such as the ESP32-C3-DevKitM-1 and
ESP32-C3-AWS-ExpressLink-DevKit, which integrate their SoCs and come
with different onboard components and pin configurations to suit various
application requirements.</p>
<h2 data-number="1.4" id="rust-in-the-context-of-embedded-systems"><span
class="header-section-number">1.4</span> Rust in the context of embedded
systems</h2>
<p>Embedded development has significantly transformed over the years,
expanding from limited, mission-specific devices to a vast landscape of
versatile applications. Initially confined to isolated, air-gapped
systems, embedded technologies now encompass a wide range of
functionalities, including edge AI and software-defined hardware. This
evolution has driven advancements in both performance and complexity,
enabling embedded systems to meet the increasing demands of modern
technology.</p>
<p>For decades, C and C++ have been the cornerstone languages in
embedded development, renowned for their efficiency and ability to meet
industry requirements. These languages have reliably supported the
creation of robust embedded applications. However, as embedded systems
become more sophisticated and the need for enhanced safety and security
intensifies, the limitations of relying solely on C and C++ become
apparent. The growing complexity of applications necessitates a shift
towards more modern programming languages that can better address these
emerging challenges.</p>
<p>Rust has emerged as a powerful alternative in the embedded
programming arena, offering a unique combination of high performance,
memory safety, and modern language features. Its ability to provide
memory safety without sacrificing speed makes Rust an attractive choice
for developing reliable and efficient embedded systems. Rust’s
expressiveness and advanced features not only enhance developer
productivity but also position it to potentially revolutionize the
embedded landscape by balancing performance with safety and modern
programming paradigms. The embedded Rust ecosystem is experiencing rapid
growth, driven by the increasing number of contributors and major
industry players adopting Rust for their projects. This expansion is
accompanied by continuous improvements in tooling and ecosystem support,
making Rust more accessible and powerful for embedded developers.
Additionally, educational resources focused on embedded Rust are
significantly improving, providing learners with the necessary materials
to stay current and effectively leverage Rust in their embedded
projects.</p>
<p>Rust emerges as a compelling choice for embedded systems. Developed
initially as Graydon Hoare’s personal project and later adopted by
Mozilla, Rust was designed to address common software failures by
eliminating unsafe coding practices. As a modern, multi-paradigm
compiled systems programming language, Rust offers memory safety,
exceptional speed, zero-cost abstractions, and high portability. These
attributes make it an ideal fit for embedded systems, which require both
performance and reliability. Additionally, Rust simplifies the
development process by providing a more integrated environment compared
to the traditional complexities of setting up make scripts, unit
testing, and package management found in languages like C and C++. Rust
has gained significant traction in both cloud and embedded environments,
with major tech companies integrating it into their systems. Notably,
Microsoft and Google have reported that Rust has helped eliminate up to
70% of their security issues in certain areas. In the embedded domain
companies adopting Rust alongside C and C++ in their job requirements.
This growing adoption underscores Rust’s effectiveness in enhancing
security, performance, and developer productivity across diverse
applications.</p>
<p>Key Features of Rust:</p>
<ol type="1">
<li>Memory Safety Rust’s unique ownership system ensures memory safety
without relying on a garbage collector. This system prevents common
issues like null pointer dereferences, buffer overflows, and data races
by enforcing strict rules on memory access and sharing.</li>
<li>Fearless Concurrency Rust facilitates safe and efficient concurrent
programming through its ownership and borrowing mechanisms. The compiler
enforces rules that allow multiple threads to access data concurrently
while minimizing the risk of data races.</li>
<li>Zero-Cost Abstractions Rust offers high-level abstractions that do
not incur runtime overhead. These abstractions are largely eliminated
during compilation, resulting in performance that rivals low-level
languages like C and C++.</li>
<li>Static Typing Being statically typed, Rust ensures that variable
types are known at compile time. This feature helps catch many errors
early in the development process, leading to more robust and reliable
software.</li>
<li>Pattern Matching Rust includes powerful pattern-matching
capabilities that allow developers to express complex conditional logic
in a concise and readable manner, enhancing code clarity and
maintainability.</li>
<li>Cross-Platform Support Rust is designed for portability across
various platforms, enabling developers to write code that can run on
different operating systems and hardware architectures with minimal
modifications.</li>
<li>Community and Ecosystem Rust boasts a vibrant and growing community,
supported by its package manager, Cargo. Cargo simplifies dependency
management and project setup, while the Rust ecosystem offers a wide
range of libraries and frameworks tailored for different purposes.</li>
<li>Integration with Other Languages Rust is engineered to interoperate
seamlessly with other languages, particularly C. This interoperability
allows Rust code to integrate with existing projects and leverage
libraries written in other languages, facilitating gradual adoption and
enhancing flexibility. Rust stands out as a robust, secure, and
efficient programming language well-suited for the demands of embedded
systems. Its combination of memory safety, concurrency support,
performance, and ease of integration positions Rust as a transformative
tool in the embedded development landscape. As more companies and
developers adopt Rust, its ecosystem and community continue to grow,
further solidifying its role in advancing embedded technology.</li>
</ol>
<h2 data-number="1.5" id="bare-metal-programming-vs.-rtos"><span
class="header-section-number">1.5</span> Bare-metal programming
vs. RTOS</h2>
<p>In embedded development, there are two primary approaches to
interacting with hardware: bare-metal programming and using a Real-Time
Operating System (RTOS). Bare-metal programming involves writing code
that directly interfaces with and controls the hardware without any
intermediary layers. This approach offers maximum control and minimal
overhead, making it ideal for resource-constrained systems, real-time
applications, and scenarios requiring precise hardware management.
Conversely, the RTOS approach introduces layers of abstraction by
running application code within an operating system environment. An RTOS
handles task scheduling and can provide additional functionalities such
as memory management, networking, and security, simplifying development
but adding overhead and reducing direct hardware control. The choice
between bare-metal and RTOS depends on the application’s complexity,
performance requirements, and the need for system responsiveness.
Generally, avoiding OS overhead is preferred to maximize performance,
but an RTOS becomes necessary as hardware and system complexity
increase, or when applications demand quick response times and efficient
power management.</p>
<p>In the context of Rust programming for embedded systems, development
can be categorized into no-std (core library) and std (standard library)
approaches. no-std development refers to bare-metal programming without
relying on the Rust standard library, providing greater control,
efficiency, and smaller memory footprints. This approach is ideal for
resource-constrained systems, real-time applications, and scenarios
requiring direct hardware interaction. Conversely, std development
involves using the Rust standard library, which offers a richer set of
functionalities, standardized APIs, and abstractions that simplify
development and enhance portability across different platforms. This
approach is suitable for more complex applications that benefit from the
extensive features provided by the standard library, albeit with
increased resource usage and some overhead.</p>
<p>Espressif supports both std and no-std development for ESP devices
through the esp-rs project on GitHub, which unifies efforts to integrate
Rust with ESP microcontrollers. The Rust ESP ecosystem emphasizes
portability by maintaining common abstractions across different ESP
devices, allowing developers to reuse codebases across similar hardware
configurations.</p>
<ul>
<li>ESP no-std Rust Ecosystem: Follows a layering approach common in
many embedded Rust projects. It includes:
<ol type="1">
<li>Peripheral Access Crate (PAC): Provides low-level access to
microcontroller registers specific to each ESP series, found in the
<code>esp-pacs</code> repository.</li>
<li>Microarchitecture Crate: Specific to processor core functions,
supporting architectures like RISC-V.</li>
<li>Hardware Abstraction Layer (HAL) Crates: Offer user-friendly APIs
for peripherals, implementing Rust’s safety mechanisms to prevent data
races and ensure correct pin configurations. These are available in the
<code>esp-hal</code> repository.</li>
<li>Embedded Trait Crates: Led by the <code>embedded-hal</code> crate,
these provide platform-agnostic traits that standardize peripheral
interactions, enhancing portability across different hardware
environments. Companion crates like <code>embedded-hal-bus</code>,
<code>embedded-hal-async</code>, and <code>embedded-hal-nb</code> extend
the functionality of <code>embedded-hal</code>.</li>
</ol></li>
<li>ESP std Rust Ecosystem: Built on top of the ESP-IDF (IoT Development
Framework), Espressif’s official framework for ESP32 and ESP8266
microcontrollers. The ESP-IDF incorporates FreeRTOS for task scheduling
and includes comprehensive features like peripheral drivers, networking
stacks, and command-line tools. Rust support is layered on top of the
existing C-based ESP-IDF through Rust’s Foreign Function Interface
(FFI), enabling developers to utilize Rust’s safety features while
leveraging the established ESP-IDF framework. Key components include:
<ol type="1">
<li>esp-idf-sys: Provides FFI bindings to the underlying ESP-IDF C APIs,
allowing Rust code to call these functions.</li>
<li>esp-idf-hal: Wraps the <code>esp-idf-sys</code> bindings with safe
Rust abstractions, supporting peripherals like GPIO, SPI, I2C, Timers,
and UART, and implementing <code>embedded-hal</code> traits.</li>
<li>esp-idf-svc: Supports the implementation of ESP-IDF services such as
Wi-Fi, Ethernet, HTTP, and MQTT, also implementing
<code>embedded-svc</code> traits for standardized service
interactions.</li>
</ol></li>
</ul>
<p>This integration ensures that Rust developers can access and utilize
ESP-IDF functionalities while maintaining Rust’s safety guarantees,
facilitating the development of robust and secure embedded
applications.</p>
<h3 data-number="1.5.1" id="development-options"><span
class="header-section-number">1.5.1</span> Development options</h3>
<p>To develop in Rust with ESP microcontrollers, developers have two
primary options: virtual hardware and physical hardware. - Virtual
Hardware: Tools like Wokwi offer an online virtual simulation
environment where developers can design, build, and test electronic
circuits and embedded projects without needing physical components.
Wokwi supports real-time simulation, Wi-Fi connectivity, and integrates
seamlessly with Rust, providing a convenient platform for education,
prototyping, and development without the complexities of hardware setup.
- Physical Hardware: Alternatively, developers can use physical ESP
development boards, which require setting up a local development
environment, including toolchains for compiling, flashing, and debugging
code. Espressif provides various development kits that integrate their
SoCs, such as the ESP32-C3-DevKitM-1 and
ESP32-C3-AWS-ExpressLink-DevKit. These boards vary in onboard components
and pin configurations to cater to different application needs. While
physical hardware offers hands-on experience and real-world testing, it
involves additional setup steps and potential hardware-related
challenges.</p>
<h3 data-number="1.5.2" id="compiler-toolchains"><span
class="header-section-number">1.5.2</span> Compiler toolchains</h3>
<p>Developing for embedded systems typically involves creating code on a
host computer and deploying it to a target microcontroller with a
different architecture. This process, known as cross-compiling, requires
a specialized compiler toolchain configured to generate binaries
compatible with the target’s architecture, such as RISC-V. A compiler
toolchain is a sequence of tools that transforms high-level code into a
microcontroller-compatible binary executable. The toolchain usually
includes three main stages:</p>
<ol type="1">
<li>Compiling: The compiler converts high-level code (e.g., C, C++,
Rust) into assembly language specific to the processor’s Instruction Set
Architecture (ISA). It performs syntax checking and code optimization
but does not handle placement in memory or include pre-compiled library
code.</li>
<li>Assembling: The assembler translates assembly instructions into
machine code, producing object files (e.g., with a <code>.obj</code>
extension). These object files contain binary representations of the
code that need to be linked.</li>
<li>Linking: The linker combines object files from the compiler and
pre-compiled libraries to create the final executable binary. It assigns
memory addresses and organizes the program image, ensuring that all
parts of the code are correctly placed in the microcontroller’s memory
space.</li>
</ol>
<p>This compilation process is essential for generating the executable
code that can run on the embedded device, ensuring compatibility between
the host development environment and the target hardware.</p>
<h3 data-number="1.5.3" id="debug-toolchains"><span
class="header-section-number">1.5.3</span> Debug Toolchains</h3>
<p>After compiling, the executable code must be transferred and debugged
on the target microcontroller. A debug toolchain encompasses the tools
required to download code to the microcontroller and perform debugging
tasks. The debug toolchain typically involves three components: 1.
Hardware Probe/Adapter: This device serves as the bridge between the
host computer and the microcontroller, connecting via interfaces such as
JTAG, Serial Wire Debug (SWD), or UART. It facilitates the flashing of
code to the microcontroller and enables live debugging. Hardware probes
can be integrated into development boards or exist as standalone
adapters. 2. Control Software: Software like OpenOCD communicates with
the hardware probe to manage programming, debugging, and testing of the
embedded target. It handles the communication protocols necessary to
interact with the microcontroller. 3. Debugging Software: Tools such as
the GNU Debugger (GDB) provide frameworks for debugging the embedded
application. They allow developers to set breakpoints, inspect registers
and memory, and step through code to identify and resolve issues within
the microcontroller.</p>
<p>Together, these tools enable developers to efficiently develop, test,
and debug embedded applications, ensuring that the code operates
correctly on the target hardware.</p>
<h1 data-number="2" id="working-with-peripherals-and-drivers"><span
class="header-section-number">2</span> Working with peripherals and
drivers</h1>
<p>In embedded systems, peripherals are essential components that serve
as the interface between the microcontroller and the physical world.
They enable the conversion of physical signals, allowing the system to
interact with external devices such as sensors, actuators, and user
inputs. These peripherals are directly connected to the
microcontroller’s physical pins and are fundamental to the functionality
of embedded applications. Common peripherals found in most commercial
microcontrollers include General Purpose Input/Output (GPIO), Timers and
Counters, Pulse Width Modulation (PWM), Analog-to-Digital Converters
(ADCs) and Digital-to-Analog Converters (DACs), and Serial
Communications.</p>
<h2 data-number="2.1" id="general-purpose-inputoutput-gpio"><span
class="header-section-number">2.1</span> General Purpose Input/Output
(GPIO)</h2>
<p>GPIO pins are versatile interfaces that can be configured as either
digital inputs or outputs, providing significant flexibility in embedded
applications. As inputs, GPIO pins can detect states such as switch or
button presses, enabling user interaction and sensor data acquisition.
As outputs, they can control devices like LEDs, motors, or other
actuators by toggling between high (1) and low (0) states. The
programmability of GPIO allows them to emulate the functions of other
peripherals, making them indispensable for a wide range of tasks within
embedded systems.</p>
<div style="page-break-after: always;">

</div>
<h2 data-number="2.2" id="timers-and-counters"><span
class="header-section-number">2.2</span> Timers and Counters</h2>
<p>Timers and Counters are peripherals designed to handle specific
timing and control functions within embedded applications. Although they
share similar underlying circuitry, their applications differ based on
their functionality. Timers are used to measure time intervals, generate
precise delays, and determine the duration of events. They are crucial
for tasks that require accurate timekeeping and scheduling. Counters, on
the other hand, track the number of occurrences of specific events, such
as counting pulses from a sensor or monitoring motor rotations. By
incrementing or decrementing based on external events or clock pulses,
counters facilitate event-driven operations and data collection in
various applications.</p>
<h2 data-number="2.3" id="pulse-width-modulation-pwm"><span
class="header-section-number">2.3</span> Pulse Width Modulation
(PWM)</h2>
<p>Pulse Width Modulation (PWM) is a technique used to simulate analog
signal variations using digital signals. It is commonly employed to
control the speed of motors and the brightness of LEDs by adjusting the
duty cycle—the percentage of time the signal remains high versus low
within a given period. By varying the duty cycle, PWM allows for precise
and efficient control over the average power delivered to a load. This
capability enables smooth and accurate adjustments in device behavior,
making PWM a critical peripheral for applications that require variable
intensity or speed control.</p>
<h2 data-number="2.4"
id="analog-to-digital-converters-and-digital-to-analog-converters"><span
class="header-section-number">2.4</span> Analog-to-Digital Converters
and Digital-to-Analog Converters</h2>
<p>ADCs and DACs are peripherals that facilitate the conversion between
digital and analog signals, bridging the gap between the digital
processing capabilities of microcontrollers and the analog nature of the
physical world. An Analog-to-Digital Converter (ADC) converts continuous
analog signals into discrete digital values. It samples an analog input,
quantizes the signal, and produces a digital representation. Common
applications of ADCs include reading data from sensors such as
temperature, light, and microphones, enabling the microcontroller to
process real-world analog data in a digital format.</p>
<p>Conversely, a Digital-to-Analog Converter (DAC) performs the reverse
function by converting digital signals into analog voltages or currents.
DACs are used in scenarios where digital devices need to interact with
the analog world, such as waveform generation or audio output. By taking
a digital input and producing a continuous analog output, DACs enable
the microcontroller to control analog devices and generate analog
signals based on digital computations.</p>
<h2 data-number="2.5" id="serial-communications"><span
class="header-section-number">2.5</span> Serial communications</h2>
<p>Serial communication peripherals enable the transmission and
reception of data in a sequential, bit-by-bit manner over a single
communication line. This method of data transfer is essential for
connecting microcontrollers with other computing devices or peripheral
components. Common serial communication protocols utilized in
microcontrollers include:</p>
<ul>
<li>UART (Universal Asynchronous Receiver/Transmitter): Facilitates
asynchronous serial communication, commonly used for debugging and
communication with PCs or other microcontrollers.</li>
<li>SPI (Serial Peripheral Interface): A synchronous protocol used for
high-speed communication between microcontrollers and peripheral devices
like sensors, displays, and memory devices.</li>
<li>I2C (Inter-Integrated Circuit): A multi-master, multi-slave protocol
ideal for communication with multiple low-speed peripherals over short
distances.</li>
</ul>
<p>Serial communications are fundamental for enabling microcontrollers
to interact with external devices, exchange data, and perform
coordinated operations within complex embedded systems.</p>
<h2 data-number="2.6" id="the-pin-interface"><span
class="header-section-number">2.6</span> The Pin Interface</h2>
<p>Microcontroller pins serve as the physical connections between the
internal peripherals and the external environment, enabling embedded
systems to interact with the outside world. Given the variety of
peripherals integrated within a microcontroller and the limited number
of pins available on different packages, these pins often need to
support multiple functions through a mechanism known as pin
multiplexing. For instance, on the ESP32-C3 controller, not all pins
support multiple functions, but some, like pin number 27, can operate as
both UART and GPIO.</p>
<p>Determining the function of each pin is managed programmatically by
configuring the microcontroller, which utilizes internal multiplexers to
select the desired function for each pin. The structure of this
selection process typically involves three stages:</p>
<ol type="1">
<li>Multiplexer Selection: The first stage involves a multiplexer that
chooses the pin function (e.g., GPIO, ADC) based on software control.
This allows a single pin to serve multiple roles depending on the
application’s requirements.</li>
<li>Peripheral Configuration: The second stage connects the selected
function to the corresponding peripheral. This peripheral is configured
and controlled by software running on the CPU, often requiring the
activation of a clock source to synchronize operations across the
system.</li>
<li>System Bus Connection: The final stage links the peripheral to the
system bus, enabling the CPU to access and manipulate the peripheral’s
internal registers for configuration and data retrieval.</li>
</ol>
<p>Understanding the pin interface is crucial, especially when
programming in bare-metal environments, as the exact structure and
capabilities of the pin multiplexers can vary between different
microcontrollers. Consulting the microcontroller’s reference manual or
datasheet is essential to comprehend the specific configurations and
functionalities available.</p>
<p>Additionally, clock management plays a significant role in the pin
interface. Clocks are used to synchronize operations across the
microcontroller, but they also contribute to power consumption. To
optimize power usage, manufacturers typically disable clocks for
peripherals that are not in use, ensuring that only the necessary
components consume power during operation.</p>
<p>The pin interface is a fundamental aspect of microcontroller design,
enabling flexible and efficient interaction with the physical world
through a limited number of pins. By leveraging pin multiplexing and
careful software configuration, microcontrollers can support a wide
range of functionalities within compact packages. Mastery of the pin
interface, including understanding multiplexer configurations and clock
management, is essential for developing robust and power-efficient
embedded systems.</p>
<h2 data-number="2.7" id="polling-vs.-interrupts"><span
class="header-section-number">2.7</span> Polling vs. interrupts</h2>
<p>In embedded systems, the processor can be notified of peripheral
events through two primary methods: polling and interrupts. Polling is a
“pull” mechanism where the processor repeatedly checks the status of a
peripheral to determine if an event has occurred. For example,
continuously monitoring a GPIO pin to detect a button press can lead to
inefficiency, especially if the event is rare or infrequent. This
constant checking wastes processing resources and power, making it
unsuitable for scalable or power-sensitive applications. Additionally,
in safety-critical systems like automotive airbag controls, polling can
introduce delays that may compromise system responsiveness and
safety.</p>
<p>Interrupts, on the other hand, operate on a “push” mechanism. In this
approach, peripherals notify the processor of events as they occur,
allowing the processor to respond immediately without the need for
constant checking. When an interrupt is triggered, the processor
temporarily halts its current tasks, retrieves the corresponding
Interrupt Service Routine (ISR) from the Interrupt Vector Table (IVT),
executes the ISR to handle the event, and then resumes normal operation.
This method is more efficient and responsive, reducing unnecessary
processor load and power consumption. However, interrupts introduce
complexity in development and debugging due to their asynchronous nature
and potential for data race conditions, where multiple threads access
shared data concurrently.</p>
<p>Interrupts consist of three main components: 1. Interrupt Source: The
peripheral generating the event, such as an ADC completion or a GPIO
button press. 2. Interrupt Vector Table (IVT): A table mapping each
interrupt source to its corresponding ISR’s memory address, allowing the
processor to locate and execute the appropriate ISR when an interrupt
occurs. 3. Interrupt Service Routine (ISR): The specific function that
executes in response to an interrupt, handling the necessary operations
related to the event.</p>
<p>Interrupts are managed by an interrupt controller, which prioritizes
and handles multiple simultaneous interrupts, ensuring that
higher-priority events are addressed first. Additionally, both
peripheral-level and CPU-level configurations are required to activate
and manage interrupts effectively.</p>
<p>A common question in embedded development is whether to use polling
or interrupts for a particular application. The answer often depends on
the specific requirements of the application:</p>
<ul>
<li><p>Application Complexity and Responsiveness: For simple
applications that do not require quick response times, polling may be
sufficient. However, as the complexity of the application or
microcontroller hardware increases, interrupts become essential to
maintain system responsiveness. In more complex systems, the overhead of
managing multiple polling loops can hinder performance and resource
utilization.</p></li>
<li><p>Event Frequency: If events occur infrequently, polling can lead
to inefficient use of processor resources, as the CPU spends time
repeatedly checking for events that rarely happen. Interrupts are more
efficient in such scenarios, as the processor remains free to perform
other tasks and only responds when an event occurs.</p></li>
<li><p>Power Consumption: In applications where power efficiency is
critical, such as battery-operated devices, interrupts are advantageous.
Microcontrollers can enter low-power sleep modes and rely on interrupts
to wake up when necessary, thereby conserving energy. Polling, which
requires the processor to remain active and continuously check for
events, can lead to higher power consumption.</p></li>
<li><p>Critical Timeliness: In safety-critical applications, such as
automotive control systems, the timely detection and response to events
are paramount. Interrupts ensure that the processor can handle urgent
events immediately, whereas polling might introduce delays that could
compromise safety.</p></li>
<li><p>Low-Power Operation: Many microcontrollers use interrupts to wake
up from low-power sleep modes. If an application requires frequent
transitions between active and sleep states to save power, interrupts
are necessary to efficiently manage these transitions without the need
for constant polling.</p></li>
</ul>
<h1 data-number="3" id="gpio-std"><span
class="header-section-number">3</span> GPIO (std)</h1>
<p>General Purpose Input/Output (GPIO) is a fundamental feature in
microcontrollers that allows digital interaction with external devices.
GPIO pins can be configured as either inputs or outputs and operate in
two modes: digital or analog.</p>
<ul>
<li>Digital Pins handle two states: high (e.g., 5V) and low (0V). They
are essential for peripherals like timers, counters, PWM, and serial
communication.</li>
<li>Analog Pins can handle a range of voltage values (e.g., 0-5V) and
are used with peripherals such as ADCs (Analog-to-Digital Converters)
and DACs (Digital-to-Analog Converters).</li>
</ul>
<p>Not all microcontroller pins support analog functions, so consulting
the device datasheet is necessary for configuration.</p>
<p>Active States in GPIO:</p>
<ul>
<li>Active High: A high voltage level represents a “true” state.
<ul>
<li><em>Example:</em> In a doorbell system, a GPIO pin connected to a
doorbell button goes high when pressed, triggering the doorbell to
ring.</li>
</ul></li>
<li>Active Low: A low voltage level represents a “true” state.
<ul>
<li><em>Example:</em> In a burglar alarm system, a window sensor pulls
the GPIO pin low when a window is opened, activating the alarm.</li>
</ul></li>
</ul>
<p>Understanding whether a GPIO pin uses an active high or active low
state is crucial for correctly setting up circuits with sensors,
switches, and other digital devices, ensuring the microcontroller
responds appropriately to changes in the external environment.</p>
<h3 data-number="3.0.1" id="configuring-gpio"><span
class="header-section-number">3.0.1</span> Configuring GPIO</h3>
<p>Configuring General Purpose Input/Output (GPIO) pins in embedded Rust
involves several systematic steps to ensure proper interaction between
the microcontroller and external devices. The process leverages Rust’s
safety features and patterns, such as the singleton pattern, to manage
hardware resources efficiently.</p>
<h4 data-number="3.0.1.1" id="take-the-peripherals"><span
class="header-section-number">3.0.1.1</span> Take the Peripherals</h4>
<ul>
<li><p>Singleton Pattern: Ensures only one instance of each peripheral
exists throughout the application.</p></li>
<li><p>Implementation:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_per <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>Peripherals::take()</code> returns an <code>Option</code>,
ensuring that subsequent calls return <code>None</code>, maintaining a
single instance.</li>
</ul></li>
</ul>
<h4 data-number="3.0.1.2" id="configure-pin-direction"><span
class="header-section-number">3.0.1.2</span> Configure Pin
Direction</h4>
<ul>
<li>PinDriver Struct: Utilized to set a pin as either input or
output.</li>
<li>Options:
<ol type="1">
<li>Input Configuration:</li>
</ol>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Allows the microcontroller to read the voltage level on the pin </span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_pin <span class="op">=</span> <span class="pp">PinDriver::</span>input(device_per<span class="op">.</span>pins<span class="op">.</span>gpio3)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<ol start="2" type="1">
<li>Output Configuration:</li>
</ol>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Enables the microcontroller to control the voltage level on the pin</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_pin <span class="op">=</span> <span class="pp">PinDriver::</span>output(device_per<span class="op">.</span>pins<span class="op">.</span>gpio2)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div></li>
<li>Type Safety: Pins have specific types (<code>Input</code> or
<code>Output</code>) that restrict available methods based on their
configuration.</li>
</ul>
<h4 data-number="3.0.1.3" id="configure-pin-pull-input-pins-only"><span
class="header-section-number">3.0.1.3</span> Configure Pin Pull (Input
Pins Only)</h4>
<ul>
<li><p>Pull-Up/Pull-Down Resistors: Stabilize input pin states.</p></li>
<li><p>Method:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_pull(<span class="pp">Pull::</span>Up)<span class="op">.</span>unwrap()<span class="op">;</span>   <span class="co">// Pull-up configuration</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>some_other_pin<span class="op">.</span>set_pull(<span class="pp">Pull::</span>Down)<span class="op">.</span>unwrap()<span class="op">;</span> <span class="co">// Pull-down configuration</span></span></code></pre></div></li>
</ul>
<h4 data-number="3.0.1.4"
id="configure-pin-drive-output-pins-only"><span
class="header-section-number">3.0.1.4</span> Configure Pin Drive (Output
Pins Only)</h4>
<ul>
<li><p>Drive Modes:</p>
<ul>
<li>Push-Pull (Default): Can drive the pin both high and low.</li>
<li>Open-Drain: Can only pull the pin low.</li>
</ul></li>
<li><p>Method to Set Open-Drain:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>some_output_pin<span class="op">.</span>into_output_od()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div></li>
<li><p>Alternative Instantiation:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">PinDriver::</span>output_od(device_per<span class="op">.</span>pins<span class="op">.</span>gpioX)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div></li>
</ul>
<h4 data-number="3.0.1.5"
id="configure-interrupt-type-input-pins-only"><span
class="header-section-number">3.0.1.5</span> Configure Interrupt Type
(Input Pins Only)</h4>
<ul>
<li><p>Interrupt Detection Types:</p>
<ul>
<li>Edge-Triggered: Detects rising, falling, or both edges.</li>
<li>Level-Triggered: Detects high or low voltage levels.</li>
</ul></li>
<li><p>Configuration Example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>PosEdge)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>NegEdge)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>AnyEdge)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>LowLevel)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>HighLevel)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div></li>
</ul>
<h4 data-number="3.0.1.6"
id="configure-drive-strength-output-pins-only"><span
class="header-section-number">3.0.1.6</span> Configure Drive Strength
(Output Pins Only)</h4>
<ul>
<li><p>Drive Strength Options: Varying current capabilities (e.g., 5mA,
10mA, 20mA, 40mA).</p></li>
<li><p>Configuration Example:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I5mA)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I10mA)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I20mA)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I40mA)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div></li>
</ul>
<h4 data-number="3.0.1.7" id="interacting-with-gpio"><span
class="header-section-number">3.0.1.7</span> Interacting with GPIO</h4>
<ol type="1">
<li>Writing/Controlling Output:
<ul>
<li><p>Methods: <code>set_low()</code> and
<code>set_high()</code></p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_low()<span class="op">.</span>unwrap()<span class="op">;</span>  <span class="co">// Set pin to low</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_high()<span class="op">.</span>unwrap()<span class="op">;</span> <span class="co">// Set pin to high</span></span></code></pre></div></li>
</ul></li>
<li>Reading Input by Polling:
<ul>
<li><p>Methods: <code>is_high()</code> and
<code>is_low()</code></p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> some_pin<span class="op">.</span>is_low() <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Input is low!&quot;</span>)<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> some_pin<span class="op">.</span>is_high() <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Input is high!&quot;</span>)<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Note: Utilizes a continuous loop to repeatedly check the pin
state.</p></li>
</ul></li>
<li>Reading Input by Interrupts:
<ul>
<li><p>Interrupt Service Routines (ISRs): Functions triggered by
specific GPIO events.</p></li>
<li><p>Configuration Steps:</p>
<ol type="1">
<li>Set Interrupt Type.</li>
<li>Subscribe ISR to Interrupt:</li>
</ol>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span> some_pin<span class="op">.</span>subscribe(gpio_int_callback)<span class="op">.</span>unwrap() <span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Enable Interrupt:</li>
</ol>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>enable_interrupt()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<ol start="4" type="1">
<li>Define ISR:</li>
</ol>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> gpio_int_callback() <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ISR code</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Example Structure:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dp <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> some_pin <span class="op">=</span> <span class="pp">PinDriver::</span>input(dp<span class="op">.</span>pins<span class="op">.</span>gpio0)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    some_pin<span class="op">.</span>set_pull(<span class="pp">Pull::</span>Up)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    some_pin<span class="op">.</span>set_interrupt_type(<span class="pp">InterruptType::</span>PosEdge)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> some_pin<span class="op">.</span>subscribe(gpio_int_callback)<span class="op">.</span>unwrap() <span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    some_pin<span class="op">.</span>enable_interrupt()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Application code...</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>ESP32-C3 Specifics: Interrupts are disabled after an event and
must be re-enabled within the ISR or processing code to handle
subsequent events.</p></li>
</ul></li>
</ol>
<h1 data-number="4" id="gpio-no-std"><span
class="header-section-number">4</span> GPIO (no-std)</h1>
<h4 data-number="4.0.0.1"
id="initialize-the-esp-gain-access-to-peripherals"><span
class="header-section-number">4.0.0.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>Before utilizing any device peripherals, it’s essential to configure
the ESP device itself. This involves setting up the device clocks and
gaining access to peripheral instances using the singleton pattern,
which ensures that only one instance of each peripheral is accessed
throughout the application. The <code>esp-hal</code> crate facilitates
this initialization with a streamlined approach.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function takes an <code>esp_hal::Config</code>
struct as an argument and returns instances of the peripherals and
system clocks. Using the default configuration simplifies the setup
process by applying standard settings.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> cpu_clock<span class="op">:</span> CpuClock<span class="op">,</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> watchdog<span class="op">:</span> WatchdogConfig<span class="op">,</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This configuration struct allows for customization of system
parameters such as CPU clock speed and watchdog settings, although the
default values are typically sufficient for basic applications.</p>
<h4 data-number="4.0.0.2" id="create-an-io-driver"><span
class="header-section-number">4.0.0.2</span> Create an IO Driver</h4>
<p>To control GPIO pins, an IO driver must be instantiated. The
<code>esp_hal::gpio</code> module provides the <code>Io</code> struct,
which serves as the driver for managing individual IO pins.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span></code></pre></div>
<p>This code creates a new IO driver instance by passing the GPIO and
IO_MUX peripherals obtained during initialization. The IO driver
provides access to the individual GPIO pins for further
configuration.</p>
<h4 data-number="4.0.0.3" id="configure-pin-direction-1"><span
class="header-section-number">4.0.0.3</span> Configure Pin
Direction</h4>
<p>After establishing the IO driver, each GPIO pin must be configured as
either an input or an output. This configuration determines how the pin
will interact with external components.</p>
<h5 data-number="4.0.0.3.1" id="input-configuration"><span
class="header-section-number">4.0.0.3.1</span> 1. Input
Configuration</h5>
<p>Configuring a pin as an input allows the microcontroller to read its
state. This is achieved using the <code>Input</code> struct, which
requires specifying the pin and its pull configuration.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new(pin<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> P<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span> pull<span class="op">:</span> Pull) <span class="op">-&gt;</span> <span class="dt">Self</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_input_pin <span class="op">=</span> <span class="pp">Input::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio3<span class="op">,</span> <span class="pp">Pull::</span>Up)<span class="op">;</span></span></code></pre></div>
<p>In this example, GPIO3 is configured as an input with a pull-up
resistor, ensuring that the pin reads a high logic level when
inactive.</p>
<h5 data-number="4.0.0.3.2" id="output-configuration"><span
class="header-section-number">4.0.0.3.2</span> 2. Output
Configuration</h5>
<p>Configuring a pin as an output enables the microcontroller to control
its state, setting it to either high or low.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new(pin<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> P<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span> initial_output<span class="op">:</span> Level) <span class="op">-&gt;</span> <span class="dt">Self</span></span></code></pre></div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_output_pin <span class="op">=</span> <span class="pp">Output::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio3<span class="op">,</span> <span class="pp">Level::</span>Low)<span class="op">;</span></span></code></pre></div>
<p>Here, GPIO3 is set as an output with an initial low level. The
push-pull configuration allows the pin to actively drive the signal both
high and low.</p>
<h4 data-number="4.0.0.4"
id="output-pins-only-configure-drive-strength"><span
class="header-section-number">4.0.0.4</span> (Output Pins Only):
Configure Drive Strength</h4>
<p>While optional, configuring the drive strength of output pins can be
necessary for applications requiring higher current levels. This is done
using the <code>set_drive_strength</code> method, which selects the
desired drive strength from the available options.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure a pin with a 5mA Drive</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I5mA)<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure a pin with a 10mA Drive</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I10mA)<span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure a pin with a 20mA Drive</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I20mA)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure a pin with a 40mA Drive</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_drive_strength(<span class="pp">DriveStrength::</span>I40mA)<span class="op">;</span></span></code></pre></div>
<p>These configurations adjust the current-driving capability of the
GPIO pin, allowing it to handle different levels of electrical load as
required by the application.</p>
<h3 data-number="4.0.1" id="interacting-with-gpio-1"><span
class="header-section-number">4.0.1</span> Interacting with GPIO</h3>
<p>Once the GPIO pins are configured, they can be interacted with
through various methods depending on their direction (input or
output).</p>
<h4 data-number="4.0.1.1" id="writingcontrolling-output"><span
class="header-section-number">4.0.1.1</span> Writing/Controlling
Output</h4>
<p>Output pins can be controlled by setting their state to high or low
using the <code>set_high</code> and <code>set_low</code> methods.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Set pin output to low</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_low()<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Set pin output to high</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>some_pin<span class="op">.</span>set_high()<span class="op">;</span></span></code></pre></div>
<p>These methods allow the microcontroller to manipulate the voltage
level on the output pin, enabling control over connected devices such as
LEDs or relays.</p>
<h4 data-number="4.0.1.2" id="reading-input-by-polling"><span
class="header-section-number">4.0.1.2</span> Reading Input by
Polling</h4>
<p>Input pins can be read by continuously polling their state using the
<code>is_high</code> and <code>is_low</code> methods within a loop.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if input pin is low</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> some_pin<span class="op">.</span>is_low() <span class="op">{</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Input is low!&quot;</span>)<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if input pin is high</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> some_pin<span class="op">.</span>is_high() <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Input is high!&quot;</span>)<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This approach involves repeatedly checking the pin’s state, which can
be resource-intensive but is straightforward to implement.</p>
<h4 data-number="4.0.1.3" id="reading-input-by-interrupts"><span
class="header-section-number">4.0.1.3</span> Reading Input by
Interrupts</h4>
<p>Interrupts provide a more efficient way to handle input changes by
triggering an Interrupt Service Routine (ISR) when specific events
occur, such as a button press.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">core::cell::</span><span class="op">{</span>Cell<span class="op">,</span> RefCell<span class="op">};</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">critical_section::</span>Mutex<span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">gpio::</span><span class="op">{</span>Event<span class="op">,</span> Input<span class="op">,</span> Pull<span class="op">,</span> Io<span class="op">},</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">prelude::</span><span class="op">*,</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> G_PIN<span class="op">:</span> Mutex<span class="op">&lt;</span>RefCell<span class="op">&lt;</span><span class="dt">Option</span><span class="op">&lt;</span>Input<span class="op">&gt;&gt;&gt;</span> <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="pp">RefCell::</span>new(<span class="cn">None</span>))<span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="co">// ISR Definition</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>handler<span class="at">]</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> gpio() <span class="op">{</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start a Critical Section</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">critical_section::</span>with(<span class="op">|</span>cs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Obtain access to global pin and clear interrupt pending flag</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        G_PIN<span class="op">.</span>borrow_ref_mut(cs)<span class="op">.</span>as_mut()<span class="op">.</span>unwrap()<span class="op">.</span>clear_interrupt()<span class="op">;</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>entry<span class="at">]</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Take Peripherals &amp; Configure Device</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create IO Driver</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Interrupt Configuration</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Register interrupt handler</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>set_interrupt_handler(gpio)<span class="op">;</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Configure pin direction</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> some_pin <span class="op">=</span> <span class="pp">Input::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio0<span class="op">,</span> <span class="pp">Pull::</span>Up)<span class="op">;</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Configure input to trigger an interrupt on the falling edge </span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// and start listening to events</span></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>    some_pin<span class="op">.</span>listen(<span class="pp">Event::</span>FallingEdge)<span class="op">;</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now that pin is configured, move the pin to the global context</span></span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>    <span class="pp">critical_section::</span>with(<span class="op">|</span>cs<span class="op">|</span> G_PIN<span class="op">.</span>borrow_ref_mut(cs)<span class="op">.</span>replace(some_pin))<span class="op">;</span></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Following Application Code</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{}</span></span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example:</p>
<ol type="1">
<li>Global Variable Setup: A global <code>G_PIN</code> variable is
defined using a <code>Mutex</code> and <code>RefCell</code> to safely
share the GPIO input pin between the main thread and the ISR.</li>
<li>ISR Definition: The <code>gpio</code> function is marked with the
<code>#[handler]</code> attribute and serves as the ISR. It clears the
interrupt flag to allow future interrupts.</li>
<li>Main Function:
<ul>
<li>Initialization: Peripherals are initialized, and an IO driver is
created.</li>
<li>Interrupt Handler Registration: The ISR is registered to handle GPIO
events.</li>
<li>Pin Configuration: GPIO0 is set as an input with a pull-up resistor
and configured to trigger an interrupt on a falling edge.</li>
<li>Global Context Assignment: The configured input pin is moved to the
global context within a critical section to ensure thread-safe
access.</li>
</ul></li>
</ol>
<h1 data-number="5" id="adcs-std"><span
class="header-section-number">5</span> ADCs (std)</h1>
<h3 data-number="5.0.1"
id="analog-nature-of-the-physical-world-and-the-need-for-adcs"><span
class="header-section-number">5.0.1</span> Analog Nature of the Physical
World and the Need for ADCs</h3>
<p>The physical world operates on analog principles, with parameters
like temperature, pressure, and speed existing as continuous values.
This analog nature creates a gap when interfacing with digital systems
such as microcontrollers and microprocessors, which rely on discrete
digital values. To bridge this gap, embedded systems must measure these
analog parameters and respond accordingly. Analog-to-Digital Converters
(ADCs) play a crucial role by converting analog voltages into digital
values, enabling digital systems to process real-world physical data
effectively.</p>
<p>An ADC consists of several key components: the input signal, which is
the analog voltage to be measured; the digital output, whose width is
determined by the ADC’s resolution (commonly 8, 10, 12, or 14 bits in
controllers); a clock that drives the sampling process; and reference
voltages that define the measurable voltage range. Higher resolution
ADCs provide greater accuracy by allowing more precise digital
representations of the analog input.</p>
<h3 data-number="5.0.2"
id="adc-conversion-process-sampling-quantization-and-encoding"><span
class="header-section-number">5.0.2</span> ADC Conversion Process:
Sampling, Quantization, and Encoding</h3>
<p>The ADC conversion process involves three main steps: 1. Sampling:
The ADC takes regular samples of the analog signal at specific intervals
determined by the sampling rate, which depends on the required
information frequency. 2. Quantization: Each sampled analog value is
assigned a discrete digital value by dividing the analog range into
finite intervals and mapping each sample to the nearest interval. 3.
Encoding: The quantized values are converted into binary format, with
the number of bits corresponding to the ADC’s resolution. For example,
an 8-bit ADC can represent 256 distinct digital values.</p>
<h3 data-number="5.0.3"
id="types-of-adcs-successive-approximation-and-delta-sigma"><span
class="header-section-number">5.0.3</span> Types of ADCs: Successive
Approximation and Delta-Sigma</h3>
<p>ADCs employ different techniques for sampling and quantization,
primarily categorized into: - Successive Approximation ADCs (SAR ADCs):
These use a binary search algorithm to iteratively approximate the input
analog signal’s value, making them common in microcontrollers like the
ESP32-C3 due to their balance of speed and accuracy. - Delta-Sigma (ΔΣ)
ADCs: These oversample the input signal and use feedback loops to
achieve high-resolution conversions, making them ideal for
precision-critical applications such as audio and instrumentation.</p>
<h3 data-number="5.0.4"
id="input-multiplexing-in-microcontrollers"><span
class="header-section-number">5.0.4</span> Input Multiplexing in
Microcontrollers</h3>
<p>Microcontrollers typically have more analog input pins than available
ADC instances, meaning each pin does not have a dedicated ADC. To
efficiently manage multiple analog inputs without requiring separate
ADCs for each, microcontrollers use multiplexing. An input multiplexer
selects one analog channel at a time, allowing the single ADC to
sequentially sample and convert multiple signals. This approach
conserves space and reduces costs while enabling the handling of
multiple analog inputs.</p>
<h3 data-number="5.0.5"
id="adc-conversion-modes-one-shot-continuous-and-scan"><span
class="header-section-number">5.0.5</span> ADC Conversion Modes:
One-Shot, Continuous, and Scan</h3>
<p>ADCs support various conversion modes to accommodate different
application needs: - One-Shot Mode: Also known as single conversion
mode, the ADC performs a single conversion and then stops until
triggered again. This mode is energy-efficient and suitable for
occasional sampling where precise timing is not critical. - Continuous
Mode: The ADC continuously performs conversions as long as it is powered
and enabled, providing a steady stream of digital data. This mode is
ideal for real-time data acquisition and processing but consumes more
power. - Scan Mode: The ADC sequentially samples multiple analog input
channels, converting each into digital form. This mode is useful for
systems with multiple sensors, allowing efficient conversion without
individual triggers. Scan mode can operate in either one-shot or
continuous manners.</p>
<h3 data-number="5.0.6" id="configuring-adcs"><span
class="header-section-number">5.0.6</span> Configuring ADCs</h3>
<h4 data-number="5.0.6.1" id="take-the-peripherals-1"><span
class="header-section-number">5.0.6.1</span> Take the Peripherals</h4>
<p>The initial step in configuring Analog-to-Digital Converters (ADCs)
involves initializing the necessary peripherals, akin to the process
used for setting up General-Purpose Input/Output (GPIO) pins. This setup
is essential for all peripherals involved in ADC operation and ensures
that each component is correctly prepared before moving on to subsequent
configuration stages.</p>
<h4 data-number="5.0.6.2" id="configure-an-adc-instance"><span
class="header-section-number">5.0.6.2</span> Configure an ADC
Instance</h4>
<p>Not all pins on a microcontroller support analog functions. For the
ESP32-C3, specific analog pins are mapped to particular ADC instances,
as detailed in the device’s reference manual. For example, using GPIO4
requires configuring ADC1. Multiple pins can share the same ADC instance
through an internal multiplexer, allowing a single ADC to handle
multiple input channels efficiently. Configuration is performed using
the <code>AdcDriver::new</code> method, which initializes the desired
ADC instance.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating an ADC Instance</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> adc1 <span class="op">=</span> <span class="pp">AdcDriver::</span>new(peripherals<span class="op">.</span>adc1)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This code snippet demonstrates how to instantiate ADC1 using the
<code>AdcDriver::new</code> method, preparing it for subsequent
configurations.</p>
<h4 data-number="5.0.6.3" id="configure-adc-pinschannels"><span
class="header-section-number">5.0.6.3</span> Configure ADC
Pin(s)/Channel(s)</h4>
<p>After instantiating the ADC, the next step is to configure the
specific pins or channels to be used. This involves setting the pin to
analog mode and configuring additional parameters such as attenuation
and resolution.</p>
<ul>
<li>Attenuation reduces the input signal’s amplitude to fit within the
ADC’s reference voltage range.</li>
<li>Resolution determines the precision of the digital representation of
the analog signal, with common options being 8, 10, 12, or 14 bits.</li>
</ul>
<p>Configuration is performed using the
<code>AdcChannelDriver::new</code> method, which requires references to
the ADC instance, the specific pin, and the channel configuration
settings.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The ADC Channel Config Configuration Struct Definition</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> AdcChannelConfig <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> attenuation<span class="op">:</span> adc_atten_t<span class="op">,</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> resolution<span class="op">:</span> Resolution<span class="op">,</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> calibration<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This struct defines the configuration parameters for an ADC channel,
including attenuation level, resolution, and whether calibration is
enabled.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure ADC Channel</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ch_config <span class="op">=</span> AdcChannelConfig <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    attenuation<span class="op">:</span> DB_11<span class="op">,</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    calibration<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    resolution<span class="op">:</span> <span class="pp">Resolution::</span>Resolution12Bit<span class="op">,</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Instantiate ADC Channel</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> adc_chan <span class="op">=</span> <span class="pp">AdcChannelDriver::</span>new(<span class="op">&amp;</span>adc1<span class="op">,</span> peripherals<span class="op">.</span>pins<span class="op">.</span>gpio4<span class="op">,</span> <span class="op">&amp;</span>ch_config)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, GPIO4 is configured as an ADC pin with 11 dB
attenuation, 12-bit resolution, and calibration enabled. The
<code>AdcChannelDriver::new</code> method ties the configuration to ADC1
and GPIO4.</p>
<h3 data-number="5.0.7" id="interacting-with-adcs"><span
class="header-section-number">5.0.7</span> Interacting with ADCs</h3>
<h4 data-number="5.0.7.1" id="blocking-read-of-input"><span
class="header-section-number">5.0.7.1</span> Blocking Read of Input</h4>
<p>To obtain a measurement from the ADC, a blocking approach can be used
where the application initiates a one-shot measurement and waits for the
result before continuing execution. This method is straightforward but
halts other code execution until the measurement is complete, making it
suitable for applications with occasional sampling needs where precise
timing is not critical.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Reading an ADC Measurement</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sample<span class="op">:</span> <span class="dt">u16</span> <span class="op">=</span> adc_chan<span class="op">.</span>read_raw()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This code initiates a one-shot ADC measurement using the
<code>read_raw</code> method, which returns a raw digital value
(<code>u16</code>) representing the sampled analog signal. To convert
this digital value back to a physical parameter (e.g., voltage), further
calculations are necessary.</p>
<p>For convenience, the <code>AdcDriver</code> also provides a
<code>read</code> method that directly returns the measured voltage in
millivolts, simplifying the process of interpreting ADC readings.</p>
<h4 data-number="5.0.7.2"
id="non-blocking-read-of-input-by-interrupts"><span
class="header-section-number">5.0.7.2</span> Non-blocking Read of Input
by Interrupts</h4>
<p>Currently, the ESP-IDF Hardware Abstraction Layer (HAL) does not
offer high-level interfaces for interrupt-based non-blocking ADC
operations. However, developers can implement non-blocking reads using
Rust’s asynchronous programming features or by accessing lower-level
bindings through <code>esp-idf-sys</code>. Non-blocking reads allow the
application to continue executing other tasks while the ADC performs
measurements, which is essential for applications requiring real-time
data processing.</p>
<p>Configuring and interacting with ADCs on the ESP32-C3 involves
several key steps:</p>
<ol type="1">
<li>Peripheral Initialization: Setting up necessary peripherals.</li>
<li>ADC Instance Configuration: Selecting and initializing the
appropriate ADC instance based on the pin used.</li>
<li>ADC Pin/Channel Configuration: Configuring specific pins with
appropriate attenuation and resolution settings.</li>
<li>Reading ADC Values: Performing measurements either through blocking
(synchronous) reads or implementing more complex non-blocking
(asynchronous) methods.</li>
</ol>
<h1 data-number="6" id="adcs-no-std"><span
class="header-section-number">6</span> ADCs (no-std)</h1>
<h4 data-number="6.0.0.1"
id="initialize-the-esp-gain-access-to-peripherals-1"><span
class="header-section-number">6.0.0.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>Before utilizing any device peripherals, the ESP device must be
configured, primarily by setting up the device clocks and gaining access
to peripheral instances. The singleton pattern is employed to ensure
that only one instance of each peripheral is accessed throughout the
application, enhancing safety and resource management.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function initializes the device with default
configuration values, returning instances of peripherals and system
clocks. The <code>esp_hal::Config</code> struct allows customization of
system parameters such as CPU clock speed and watchdog settings, though
the default values are typically sufficient for basic applications.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> cpu_clock<span class="op">:</span> CpuClock<span class="op">,</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> watchdog<span class="op">:</span> WatchdogConfig<span class="op">,</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This configuration struct enables developers to tailor the system’s
behavior by adjusting clock speeds and watchdog parameters as
needed.</p>
<h4 data-number="6.0.0.2" id="create-an-io-driver-1"><span
class="header-section-number">6.0.0.2</span> Create an IO Driver</h4>
<p>With access to peripherals established, the next step is to create an
IO driver, which provides control over individual IO pins. The
<code>esp_hal::gpio</code> module offers the <code>Io</code> struct for
this purpose.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span></code></pre></div>
<p>This code initializes the IO driver by passing the GPIO and IO_MUX
peripherals obtained during initialization. The IO driver facilitates
further configuration and management of specific GPIO pins.</p>
<h4 data-number="6.0.0.3" id="configure-analog-pin-and-channel"><span
class="header-section-number">6.0.0.3</span> Configure Analog Pin and
Channel</h4>
<p>Not all pins on a microcontroller support analog functions. Depending
on the chosen pin, the corresponding ADC instance must be configured.
For example, using GPIO4 requires configuring ADC1. Multiple pins can be
sampled by the same ADC instance through an internal multiplexer.</p>
<p>After selecting the appropriate pin, the ADC channel configuration is
created by specifying the pin and attenuation settings. Attenuation
reduces the amplitude of the input signal to fit within the ADC’s
reference voltage range.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> Attenuation <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    Attenuation0dB <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    Attenuation2p5dB <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    Attenuation6dB <span class="op">=</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    Attenuation11dB <span class="op">=</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create instance for ADC configuration parameters</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> adc_config <span class="op">=</span> <span class="pp">AdcConfig::</span>new()<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable a pin with attenuation</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> adc_pin <span class="op">=</span> adc_config<span class="op">.</span>enable_pin(</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    pin_instance<span class="op">,</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">Attenuation::</span>Attenuation11dB<span class="op">,</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>In this example, the ADC channel is configured with an attenuation of
11 dB for a specific pin. Attenuation allows the ADC to handle higher
input voltages by scaling them down, ensuring accurate measurements
within the ADC’s reference voltage range.</p>
<h4 data-number="6.0.0.4" id="create-an-adc-driver"><span
class="header-section-number">6.0.0.4</span> Create an ADC Driver</h4>
<p>With the ADC channel configured, an ADC driver can be created to
manage the ADC instance and perform measurements. The
<code>esp_hal::analog::adc::Adc</code> type provides the necessary
abstraction for this purpose.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create ADC Driver for ADC1</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> adc1 <span class="op">=</span> <span class="pp">Adc::</span>new(peripherals<span class="op">.</span>ADC1<span class="op">,</span> adc_config)<span class="op">;</span></span></code></pre></div>
<p>This code initializes an ADC driver for ADC1, associating it with the
previously configured ADC channel. The ADC driver enables the
application to perform analog measurements through the configured ADC
instance.</p>
<h3 data-number="6.0.1" id="interacting-with-adcs-1"><span
class="header-section-number">6.0.1</span> Interacting with ADCs</h3>
<p>Once configured, ADCs can be interacted with to perform measurements.
This involves reading analog input values either in a blocking or
non-blocking manner.</p>
<h4 data-number="6.0.1.1" id="blocking-read-of-input-1"><span
class="header-section-number">6.0.1.1</span> Blocking Read of Input</h4>
<p>A blocking read involves initiating a one-shot measurement and
waiting until the result is available. This ensures that the application
receives the measurement before proceeding, albeit at the cost of
halting other operations during the wait.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> adc_reading<span class="op">:</span> <span class="dt">u16</span> <span class="op">=</span> adc1<span class="op">.</span>read_oneshot(<span class="op">&amp;</span><span class="kw">mut</span> analog_pin)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>While labeled as non-blocking, the <code>read_oneshot</code> method
returns a <code>WouldBlock</code> error if the ADC is not ready,
indicating that the operation cannot be completed immediately. To
implement a true blocking approach, the <code>block!</code> macro from
the <code>nb</code> crate can be used to wait until the measurement is
ready.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> adc_reading<span class="op">:</span> <span class="dt">u16</span> <span class="op">=</span> <span class="pp">nb::block!</span>(adc1<span class="op">.</span>read_oneshot(<span class="op">&amp;</span><span class="kw">mut</span> pin))<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>The <code>block!</code> macro ensures that the code waits until the
ADC reading is available before proceeding, providing a straightforward
way to obtain accurate measurements without handling errors
manually.</p>
<h1 data-number="7" id="programming-timers-counters-std"><span
class="header-section-number">7</span> Programming Timers &amp; Counters
(std)</h1>
<p>Timers and counters are fundamental peripherals in embedded systems,
offering powerful functionalities despite their simplicity. A timer
generates periodic or one-time signals at specified intervals and can
measure the time between external hardware events. Common applications
include triggering interrupts for updating displays, measuring button
press durations, or creating delays. Conversely, a counter increments
its count with each event occurrence, useful for tracking the number of
button presses, motor revolutions, or network packets received. While
timers and counters can be implemented in software, hardware
implementations are preferred for maintaining high accuracy and
efficiency. Most microcontrollers, including the ESP32-C3, come equipped
with multiple dedicated timers and counters, each offering various
features tailored to specific tasks.</p>
<h3 data-number="7.0.1" id="countertimer-structure-and-features"><span
class="header-section-number">7.0.1</span> Counter/Timer Structure and
Features</h3>
<p>Timers and counters share a similar core circuitry consisting of a
count register that increments with each clock event. The primary
difference lies in the nature of the clock input: timers use a
synchronous periodic clock signal to measure time intervals, whereas
counters use asynchronous event-based signals to tally occurrences.
Advanced microcontroller timers, such as those in the ESP32-C3, include
additional features to enhance functionality:</p>
<ol type="1">
<li>Interrupts: Notify the processor of overflow events without
continuous polling.</li>
<li>Auto Reload: Automatically reload a predefined value upon overflow
for repetitive timing tasks.</li>
<li>Clock Source Configuration: Adjust the timer’s clock frequency using
prescalers to achieve desired timing resolutions.</li>
<li>Upcounting/Downcounting: Configure the timer to count upwards or
downwards based on application needs.</li>
<li>Cascading Counters: Combine multiple counters to extend the maximum
count range beyond a single register’s capacity.</li>
</ol>
<p>These features enable timers and counters to handle complex tasks
efficiently, such as generating precise time delays, managing periodic
interrupts, or tracking high-frequency events.</p>
<h3 data-number="7.0.2" id="countertimer-modes-of-operation"><span
class="header-section-number">7.0.2</span> Counter/Timer Modes of
Operation</h3>
<p>Timers and counters support various modes of operation to cater to
different application requirements:</p>
<ol type="1">
<li>One-Shot Mode: The timer counts up or down once until it overflows,
then stops. Ideal for generating single pulses or measuring single
events.</li>
<li>Continuous Mode: The timer continuously counts without stopping,
suitable for ongoing measurements or periodic interrupts.</li>
<li>Input Capture: Captures the timer’s current count value upon
external events, useful for measuring event durations or signal
frequencies.</li>
<li>Output Compare: Triggers an action when the timer’s count matches a
predefined value, enabling waveform generation or synchronized
actions.</li>
<li>Pulse Width Modulation (PWM): A specialized form of output compare
that generates waveforms with adjustable duty cycles, commonly used for
motor control, LED dimming, and signal generation.</li>
</ol>
<p>Timers and counters are versatile peripherals essential for managing
time-based and event-based tasks in embedded systems. The ESP32-C3
microcontroller offers robust timer and counter functionalities with
features like interrupts, auto-reload, clock source configuration, and
various modes of operation. By leveraging these capabilities, developers
can implement precise timing mechanisms, event counting, waveform
generation, and more. The provided Rust code examples illustrate basic
configurations for one-shot and continuous timer modes, including
interrupt handling, enabling developers to integrate timers and counters
effectively into their applications.</p>
<h3 data-number="7.0.3" id="configuring-timers"><span
class="header-section-number">7.0.3</span> Configuring Timers</h3>
<p>Configuring timers on the ESP32-C3 involves several methodical steps
to ensure accurate and efficient timing operations. This process is
similar to configuring other peripherals like GPIOs and includes
initializing peripherals, setting up timer instances, and configuring
specific timer settings.</p>
<h4 data-number="7.0.3.1" id="take-the-peripherals-2"><span
class="header-section-number">7.0.3.1</span> Take the Peripherals</h4>
<p>The initial step mirrors the peripheral initialization process used
for GPIOs, as demonstrated before. This involves acquiring and setting
up the necessary peripherals required for timer operation.</p>
<h4 data-number="7.0.3.2" id="configure-a-timer-instance"><span
class="header-section-number">7.0.3.2</span> Configure a Timer
Instance</h4>
<p>The ESP32-C3 chip features two hardware timer groups, each containing
a general-purpose hardware timer and a system watchdog timer. These
timers are 54-bit wide with 16-bit prescalers and offer functionalities
such as auto-reload, alarm generation, up/down counting, and interrupt
generation. To configure a timer, the <code>TimerDriver::new</code>
method from the <code>esp_idf_hal::timer</code> module is used. This
method requires a Timer peripheral instance (e.g., Timer00) and a
reference to a configuration instance.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating a Timer Instance</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_timer <span class="op">=</span> <span class="pp">TimerDriver::</span>new(peripherals<span class="op">.</span>timer00<span class="op">,</span> <span class="op">&amp;</span><span class="pp">Config::</span>new())</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, <code>Timer00</code> is instantiated using the
default configuration, which sets the divider to 80, and both
<code>xtal</code> and <code>auto_reload</code> to <code>false</code>.
The ESP32-C3 provides two general-purpose timers, <code>timer00</code>
and <code>timer01</code>, which can be chosen based on application
requirements.</p>
<h4 data-number="7.0.3.3" id="configure-timer-control-methods"><span
class="header-section-number">7.0.3.3</span> Configure Timer Control
Methods</h4>
<p>After instantiating the timer, various control methods are available
to manage its behavior. These methods allow enabling/disabling the
timer, setting the counter value, configuring alarms, and more.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable or disable the timer</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> enable(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> enable<span class="op">:</span> <span class="dt">bool</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Manually set the current counter value</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> set_counter(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> value<span class="op">:</span> <span class="dt">u64</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable or disable the alarm feature</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> enable_alarm(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> enable<span class="op">:</span> <span class="dt">bool</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Set the alarm compare value</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> set_alarm(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> value<span class="op">:</span> <span class="dt">u64</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>These methods provide granular control over the timer’s operation,
allowing developers to start, stop, reset, and configure alarm
conditions as needed.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Set start/reset count value to zero</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>some_timer<span class="op">.</span>set_counter(<span class="dv">0_u64</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Set timer to generate an alarm when the count reaches 1000</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>some_timer<span class="op">.</span>set_alarm(<span class="dv">1000_u64</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable the alarm to occur</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>some_timer<span class="op">.</span>enable_alarm(<span class="cn">true</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable timer to start counting</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>some_timer<span class="op">.</span>enable(<span class="cn">true</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, the timer is configured to start counting from zero
and generate an alarm when the count reaches 1000. The alarm is enabled,
and the timer is started to begin counting.</p>
<p>Note: While the ESP32-C3 timers support features like up/down
counting, the current <code>esp-idf-hal</code> library may not provide
high-level methods for these functionalities. Developers may need to use
lower-level abstractions or await future library updates to access these
features.</p>
<h3 data-number="7.0.4" id="interacting-with-timers"><span
class="header-section-number">7.0.4</span> Interacting with Timers</h3>
<h4 data-number="7.0.4.1" id="controlling-timerscounters"><span
class="header-section-number">7.0.4.1</span> Controlling
Timers/Counters</h4>
<p>To utilize timers effectively, developers typically set a start value
and enable the timer to begin counting. The timer will continue counting
until it reaches its maximum value, resets to the start value, or
matches a predefined compare value (alarm). The <code>TimerDriver</code>
methods facilitate these actions, allowing for precise control over the
timer’s behavior.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Initialize Timer Clock Value</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timer_clk <span class="op">=</span> <span class="dv">1_000_000_u64</span><span class="op">;</span> <span class="co">// 1 MHz clock</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable Timer to Start Counting</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>some_timer<span class="op">.</span>enable(<span class="cn">true</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reset Timer Count to start from 0</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>set_counter(<span class="dv">0_u64</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Perform Some Operations</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Read Counter Value</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> count <span class="op">=</span> some_timer<span class="op">.</span>counter()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert to Seconds</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> count_secs <span class="op">=</span> count <span class="op">/</span> timer_clk<span class="op">;</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Print Timer Elapsed Time (from 0)</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Elapsed Timer Duration in Seconds is {}&quot;</span><span class="op">,</span> count_secs)<span class="op">;</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Additional logic can be added here</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example, the timer is enabled to start counting from zero.
The loop performs operations and periodically reads the current count
value, converting it to seconds based on the timer’s clock frequency (1
MHz in this case).</p>
<h4 data-number="7.0.4.2"
id="reading-timerscounters-by-interrupts"><span
class="header-section-number">7.0.4.2</span> Reading Timers/Counters by
Interrupts</h4>
<p>Using interrupts allows the timer to notify the application when an
alarm or overflow event occurs, eliminating the need for continuous
polling. This is achieved by configuring an Interrupt Service Routine
(ISR) that gets called upon timer events.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ISR Definition</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> timer_alarm_int_callback() <span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ISR Code: Handle the timer alarm event</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Main Function</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Any Startup Code</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Take Peripherals</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Configure Timer</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> some_timer <span class="op">=</span> <span class="pp">TimerDriver::</span>new(peripherals<span class="op">.</span>timer00<span class="op">,</span> <span class="op">&amp;</span><span class="pp">Config::</span>new())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Timer Settings</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set Start/Reset Count Value to Zero</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>set_counter(<span class="dv">0_u64</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set Timer to Generate an Alarm if its Value Reaches 1000</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>set_alarm(<span class="dv">1000_u64</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Enable the Alarm to Occur</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>enable_alarm(<span class="cn">true</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Interrupt Setup</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Attach the ISR to the timer interrupt</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span> some_timer<span class="op">.</span>subscribe(timer_alarm_int_callback)<span class="op">.</span>unwrap() <span class="op">}</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Enable Interrupts</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>enable_interrupt()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Enable Timer to Start Counting</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    some_timer<span class="op">.</span>enable(<span class="cn">true</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Following Application Code</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Main application logic can continue here</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This example demonstrates setting up a timer to generate an alarm
when the count reaches 1000. An ISR
(<code>timer_alarm_int_callback</code>) is defined to handle the alarm
event. The timer is configured, the ISR is subscribed to the timer
interrupt, and interrupts are enabled to allow the ISR to be called upon
timer events.</p>
<p>Configuring timers on the ESP32-C3 involves initializing the
necessary peripherals, setting up timer instances with appropriate
configurations, and utilizing control methods to manage timer
operations. Timers can operate in various modes, such as one-shot or
continuous, and can interact with interrupts to handle overflow or alarm
events efficiently. The provided Rust code examples illustrate how to
create and configure timers, set alarms, and handle timer events through
both polling and interrupt-driven approaches. By leveraging these
configurations, developers can implement precise timing mechanisms,
event counting, and responsive interrupt handling in their embedded
applications.</p>
<h1 data-number="8" id="programmingtimers-counters-no-std"><span
class="header-section-number">8</span> ProgrammingTimers &amp; Counters
(no-std)</h1>
<p>Configuring timers on ESP devices using Rust involves a structured
process that ensures precise time-based operations essential for various
embedded applications. This configuration leverages the
<code>esp-hal</code> crate, which provides abstractions for managing
timer peripherals within the ESP-IDF framework. The setup process is
divided into several key steps, each building upon the previous to
establish a reliable timer mechanism.</p>
<h4 data-number="8.0.0.1"
id="initialize-the-esp-gain-access-to-peripherals-2"><span
class="header-section-number">8.0.0.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>The first step mirrors the initialization process outlined in
previous sections. It involves configuring the ESP device and gaining
access to its peripherals using the singleton pattern, which ensures
that only one instance of each peripheral is accessed throughout the
application. This is achieved with the <code>esp_hal::init</code>
function, which initializes the device with default configurations.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function accepts an
<code>esp_hal::Config</code> struct and returns instances of the
peripherals and system clocks, preparing the device for subsequent
configurations.</p>
<h4 data-number="8.0.0.2"
id="instantiate-a-timer-group-obtain-timer-handle"><span
class="header-section-number">8.0.0.2</span> Instantiate a Timer Group
&amp; Obtain Timer Handle</h4>
<p>Once peripherals are initialized, the next step is to create a timer
group and obtain a handle for a specific timer within that group. Timer
groups allow for the organization and management of multiple timers,
facilitating coordinated timing operations.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timer_group0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb45"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Instantiate Timer0 in Timer Group 0</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> timer0 <span class="op">=</span> timer_group0<span class="op">.</span>timer0<span class="op">;</span></span></code></pre></div>
<p>By instantiating <code>timer_group0</code> and obtaining
<code>timer0</code>, developers can manage and control Timer 0 within
Timer Group 0, setting the foundation for precise timing operations.</p>
<h4 data-number="8.0.0.3" id="configure-analog-pin-and-channel-1"><span
class="header-section-number">8.0.0.3</span> Configure Analog Pin and
Channel</h4>
<p>Configuring the timer involves setting up the timer’s parameters,
such as the start value, compare value, and enabling features like
auto-reload. This ensures that the timer operates according to the
desired specifications, whether it’s for counting, generating
interrupts, or triggering alarms.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Start the timer</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> start(<span class="op">&amp;</span><span class="kw">self</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Stop the timer</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> stop(<span class="op">&amp;</span><span class="kw">self</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Reset the timer</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> reset(<span class="op">&amp;</span><span class="kw">self</span>)</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable auto-reload of load value</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> enable_auto_reload(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> auto_reload<span class="op">:</span> <span class="dt">bool</span>)</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Load a compare value to the timer</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> load_value(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> value<span class="op">:</span> MicrosDurationU64) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Set Start/Reset Count Value to Zero</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>timer0<span class="op">.</span>reset()<span class="op">;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable Timer to Start Counting</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>timer0<span class="op">.</span>start()<span class="op">;</span></span></code></pre></div>
<p>In this example, <code>timer0</code> is reset to zero and then
started, initiating the counting process. These methods allow for
precise control over the timer’s behavior, enabling functionalities such
as periodic interrupts or timed events.</p>
<h4 data-number="8.0.0.4" id="create-an-adc-driver-1"><span
class="header-section-number">8.0.0.4</span> Create an ADC Driver</h4>
<p>After configuring the timer, an ADC driver can be created to manage
analog-to-digital conversions. This step involves associating the timer
with the ADC instance, facilitating synchronized analog measurements
based on timer events.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a Global Variable for timer to pass between threads.</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> G_TIMER<span class="op">:</span> Mutex<span class="op">&lt;</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    RefCell<span class="op">&lt;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Option</span><span class="op">&lt;</span>Timer<span class="op">&lt;</span>Timer0<span class="op">&lt;</span>TIMG0<span class="op">&gt;,</span> <span class="pp">esp_hal::</span>Blocking<span class="op">&gt;&gt;,</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&gt;,</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="pp">RefCell::</span>new(<span class="cn">None</span>))<span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ISR Definition</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>handler<span class="at">]</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> tg0_t0_level() <span class="op">{</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start a Critical Section</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">critical_section::</span>with(<span class="op">|</span>cs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Clear Timer Interrupt Pending Flag</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        G_TIMER</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>borrow_ref_mut(cs)</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>as_mut()</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>clear_interrupt()<span class="op">;</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Re-activate Timer Alarm For Interrupts to Occur again</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        G_TIMER</span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>borrow_ref_mut(cs)</span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>as_mut()</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>unwrap()</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>set_alarm_active(<span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Any other ISR Code</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>entry<span class="at">]</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Take Peripherals</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instantiate TimerGroup0</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timer_group0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Instantiate Timer0 in Timer Group0</span></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timer0 <span class="op">=</span> timer_group0<span class="op">.</span>timer0<span class="op">;</span></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Interrupt Configuration</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Configure timer to trigger an interrupt every second</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Load count equivalent to 1 second</span></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>    timer0</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>load_value(<span class="pp">MicrosDurationU64::</span>micros(<span class="dv">1_000_000</span>))</span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Enable Alarm to generate interrupts</span></span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>    timer0<span class="op">.</span>set_alarm_active(<span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Activate counter</span></span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>    timer0<span class="op">.</span>set_counter_active(<span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Attach Interrupt and Start listening for timer events</span></span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>    timer0<span class="op">.</span>set_interrupt_handler(tg0_t0_level)<span class="op">;</span></span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Following Application Code</span></span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>    timer0<span class="op">.</span>listen()<span class="op">;</span></span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Move the timer to the global context</span></span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a>    <span class="pp">critical_section::</span>with(<span class="op">|</span>cs<span class="op">|</span> <span class="op">{</span></span>
<span id="cb48-57"><a href="#cb48-57" aria-hidden="true" tabindex="-1"></a>        G_TIMER<span class="op">.</span>borrow_ref_mut(cs)<span class="op">.</span>replace(timer0)</span>
<span id="cb48-58"><a href="#cb48-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb48-59"><a href="#cb48-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{}</span></span>
<span id="cb48-60"><a href="#cb48-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this comprehensive example:</p>
<ol type="1">
<li>Global Variable Setup: A global <code>G_TIMER</code> variable is
defined using a <code>Mutex</code> and <code>RefCell</code> to safely
share the timer instance between the main thread and the Interrupt
Service Routine (ISR).</li>
<li>ISR Definition: The <code>tg0_t0_level</code> function is marked
with the <code>#[handler]</code> attribute and serves as the ISR. It
clears the interrupt flag and re-activates the timer alarm to allow for
subsequent interrupts.</li>
<li>Main Function:
<ul>
<li>Initialization: Peripherals are initialized, and a timer group is
instantiated.</li>
<li>Timer Configuration: <code>timer0</code> is configured to trigger an
interrupt every second by loading a count value equivalent to one second
(<code>1_000_000</code> microseconds) and enabling the alarm.</li>
<li>Interrupt Handler Registration: The ISR is attached to
<code>timer0</code> to handle timer events.</li>
<li>Global Context Assignment: The configured timer is moved to the
global context within a critical section to ensure thread-safe
access.</li>
</ul></li>
</ol>
<h4 data-number="8.0.0.5" id="reading-timerscounters-by-polling"><span
class="header-section-number">8.0.0.5</span> Reading Timers/Counters by
Polling</h4>
<p>Timers can be read by continuously polling their current value. This
method involves checking the timer’s count at regular intervals to
determine the elapsed time or to trigger specific actions based on the
timer’s state.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Activate Counter to Start Counting</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>timer0<span class="op">.</span>start()<span class="op">;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reset Timer Count (to count from 0)</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    timer0<span class="op">.</span>reset()<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Perform Some Operations</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Determine Duration</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dur <span class="op">=</span> some_timer<span class="op">.</span>now()<span class="op">.</span>duration_since_epoch()<span class="op">.</span>to_secs()<span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Print Timer Elapsed Time (from 0)</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Elapsed Timer Duration in Seconds is {}&quot;</span><span class="op">,</span> dur)<span class="op">;</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example, <code>timer0</code> is started and then continuously
reset within a loop. The elapsed time since the epoch is calculated and
printed, providing real-time feedback on the timer’s state. This polling
approach ensures that the application can monitor the timer’s progress
and react accordingly.</p>
<h1 data-number="9" id="pwm-std"><span
class="header-section-number">9</span> PWM (std)</h1>
<p>Pulse Width Modulation (PWM) is a waveform generation technique that
controls the duration of the “on” time within each period of a square
wave signal. Unlike traditional square waves, which have a fixed 50%
duty cycle (equal on and off times), PWM allows the on-time (Ton) to
vary between 0% (completely off) and 100% (always on). This variability
in the duty cycle—the ratio of on-time to the total period—enables
precise control over the average voltage and current delivered to
electronic components. For example, a PWM signal with a 50% duty cycle
and a peak voltage of 5V results in an average voltage of 2.5V.</p>
<h3 data-number="9.0.1" id="duty-cycle-and-its-importance"><span
class="header-section-number">9.0.1</span> Duty Cycle and Its
Importance</h3>
<p>The duty cycle is a crucial parameter in PWM, representing the
percentage of time the signal is in the “on” state within a single
period. Adjusting the duty cycle directly affects the average voltage of
the PWM signal. For instance, increasing the duty cycle raises the
average voltage, while decreasing it lowers the average voltage. This
property makes PWM highly effective for applications that require
varying power levels, such as controlling LED brightness, motor speeds,
servo positions, and heating elements. By rapidly switching the signal
on and off, PWM can simulate analog voltage levels, allowing digital
systems to interface seamlessly with analog components.</p>
<h3 data-number="9.0.2" id="pwm-in-embedded-systems"><span
class="header-section-number">9.0.2</span> PWM in Embedded Systems</h3>
<p>In embedded systems, PWM is widely used for current control tasks. By
adjusting the duty cycle, PWM can control the amount of electricity
flowing through a load. This is analogous to adjusting a faucet to
control water flow—turning it on more frequently increases the flow,
while turning it off more often decreases it. PWM achieves this by
altering the proportion of time the signal is high (on) versus low (off)
within each cycle. This technique is essential for applications like
dimming LEDs, regulating motor speeds, positioning servos, and managing
the intensity of heating elements.</p>
<h3 data-number="9.0.3" id="pwm-generation-in-esp32-c3"><span
class="header-section-number">9.0.3</span> PWM Generation in
ESP32-C3</h3>
<p>The ESP32-C3 microcontroller generates PWM signals using dedicated
peripherals separate from its general-purpose timers. Specifically, the
ESP32-C3 includes two peripherals for PWM generation:</p>
<ol type="1">
<li><p>LED PWM Controller (LEDC): Primarily designed for LED control,
the LEDC peripheral can generate PWM signals with high precision. It
offers six independent PWM generators (channels) driven by four timers.
Each timer can be independently configured for clock and counting, while
PWM channels select one of these timers as their reference. The PWM
outputs are then connected to GPIO pins to produce the desired
waveform.</p></li>
<li><p>Remote Control Peripheral (RMT): While not the focus of this
chapter, the RMT peripheral also supports PWM generation and can be used
for various remote control and communication applications.</p></li>
</ol>
<p>The LEDC peripheral’s flexibility allows it to handle multiple PWM
channels simultaneously, each with its own configuration, making it
suitable for a wide range of applications beyond just LED control.</p>
<p>Pulse Width Modulation is a versatile and essential technique in
embedded systems for controlling the average voltage and current
delivered to electronic components by varying the duty cycle of square
wave signals. In the ESP32-C3 microcontroller, PWM is efficiently
handled by dedicated peripherals like the LEDC, which offers multiple
channels and timers for generating precise PWM signals. This capability
enables developers to implement a variety of applications, including LED
dimming, motor speed control, and more, by leveraging the adjustable
duty cycle to achieve the desired power levels and performance.</p>
<h3 data-number="9.0.4"
id="configuring-pulse-width-modulation-pwm"><span
class="header-section-number">9.0.4</span> Configuring Pulse Width
Modulation (PWM)</h3>
<p>Configuring PWM on the ESP32-C3 involves a series of methodical steps
to set up the LED PWM Controller (LEDC) peripheral for generating
precise PWM signals. This process ensures that PWM channels are
correctly initialized and configured to control various applications
such as LED brightness, motor speed, and more.</p>
<h4 data-number="9.0.4.1" id="take-the-peripherals-3"><span
class="header-section-number">9.0.4.1</span> Take the Peripherals</h4>
<p>The initial step in configuring PWM mirrors the peripheral
initialization process used in previous configurations, such as GPIO
setup. This involves acquiring and setting up the necessary peripherals
required for PWM operation, ensuring that all components are ready for
subsequent configuration stages.</p>
<h4 data-number="9.0.4.2" id="configure-an-ledc-timer-instance"><span
class="header-section-number">9.0.4.2</span> Configure an LEDC Timer
Instance</h4>
<p>The LEDC peripheral is divided into two main parts: timers and PWM
generators/channels. Timers drive the PWM channels and are independently
configurable from the PWM generators. To configure an LEDC timer, the
<code>LedcTimerDriver</code> struct’s <code>new</code> method is used,
which requires two arguments: an LEDC timer peripheral instance (e.g.,
<code>timer0</code>) and a <code>TimerConfig</code> configuration
instance.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The Timer Configuration Struct</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> TimerConfig <span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> frequency<span class="op">:</span> Hertz<span class="op">,</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> resolution<span class="op">:</span> Resolution<span class="op">,</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> speed_mode<span class="op">:</span> SpeedMode<span class="op">,</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>TimerConfig</code> struct includes: - frequency: Defines
the desired timer clock frequency. - resolution: Specifies the timer’s
counter width using an enumeration. - speed_mode: Specifies the timer
speed mode, with the ESP32-C3 offering a single option.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure Timer0 with a clock of 50Hz and a resolution of 14 bits</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timer_driver <span class="op">=</span> <span class="pp">LedcTimerDriver::</span>new(</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>ledc<span class="op">.</span>timer0<span class="op">,</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span><span class="pp">TimerConfig::</span><span class="kw">default</span>()</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>frequency(<span class="dv">50</span><span class="op">.</span>Hz())</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>resolution(<span class="pp">Resolution::</span>Bits14)<span class="op">,</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, <code>timer0</code> is configured with a 50Hz clock
frequency and a 14-bit resolution. The ESP32-C3 LEDC peripheral includes
four timers (<code>timer0</code> to <code>timer3</code>), each of which
can be independently selected based on application requirements.</p>
<h4 data-number="9.0.4.3"
id="configure-an-ledc-pwm-channel-instance"><span
class="header-section-number">9.0.4.3</span> Configure an LEDC PWM
Channel Instance</h4>
<p>After configuring the timer, the next step is to set up the PWM
channel. This is done using the <code>LedcDriver</code> struct’s
<code>new</code> method, which requires three parameters: a PWM channel
instance (e.g., <code>channel0</code>), the previously configured timer
driver instance, and a GPIO pin instance where the PWM signal will be
output.</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating an LEDC PWM Channel Instance</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> driver <span class="op">=</span> <span class="pp">LedcDriver::</span>new(</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>ledc<span class="op">.</span>channel0<span class="op">,</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    timer_driver<span class="op">,</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>pins<span class="op">.</span>gpio7<span class="op">,</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, <code>channel0</code> of the LEDC peripheral is
associated with <code>gpio7</code> for PWM signal output. The
<code>LedcDriver</code> abstraction handles the necessary pin
configurations internally, simplifying the setup process.</p>
<h3 data-number="9.0.5" id="interacting-with-pwm"><span
class="header-section-number">9.0.5</span> Interacting with PWM</h3>
<h4 data-number="9.0.5.1" id="controlling-the-ledc-pwm-peripheral"><span
class="header-section-number">9.0.5.1</span> Controlling the LEDC PWM
Peripheral</h4>
<p>Once the PWM channel is configured, controlling the PWM signal
involves setting the desired duty cycle and enabling the PWM output. The
duty cycle determines the proportion of time the signal is in the “on”
state within each period.</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configuring Duty Cycle and Enabling PWM Output</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Set Desired Duty Cycle</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>some_ledc_driver_inst<span class="op">.</span>set_duty(<span class="dv">1000_u32</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable PWM Output</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>some_ledc_driver_inst<span class="op">.</span>enable()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>Here, the <code>set_duty</code> method sets the duty cycle based on a
value that corresponds to the PWM resolution. After setting the duty
cycle, the <code>enable</code> method activates the PWM signal on the
configured GPIO pin.</p>
<h4 data-number="9.0.5.2"
id="reading-from-the-ledc-pwm-peripheral"><span
class="header-section-number">9.0.5.2</span> Reading from the LEDC PWM
Peripheral</h4>
<p>While generating PWM signals typically doesn’t require reading
events, it’s often useful to read the current duty cycle or determine
the maximum possible duty value for dynamic adjustments.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configuring 20% Duty Cycle and Enabling PWM Output</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Get Maximum Possible Duty Value</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> max_duty <span class="op">=</span> some_ledc_driver_inst<span class="op">.</span>get_max_duty()<span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Set Duty Cycle to 20%</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>some_ledc_driver_inst<span class="op">.</span>set_duty(max_duty <span class="op">*</span> <span class="dv">20</span> <span class="op">/</span> <span class="dv">100</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable PWM Output</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>some_ledc_driver_inst<span class="op">.</span>enable()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, the <code>get_max_duty</code> method retrieves the
maximum duty cycle value based on the configured resolution. The duty
cycle is then set to 20% by calculating 20% of the maximum duty value,
and the PWM output is enabled accordingly.</p>
<p>Configuring PWM on the ESP32-C3 involves initializing the necessary
peripherals, setting up LEDC timers, and configuring PWM channels to
generate precise PWM signals. By following these steps and utilizing the
provided code examples, developers can effectively control various
applications such as LED brightness, motor speeds, and more. The LEDC
peripheral’s flexibility, with multiple timers and channels, allows for
simultaneous PWM signal generation tailored to diverse embedded system
requirements.</p>
<h1 data-number="10" id="pwm-no-std"><span
class="header-section-number">10</span> PWM (no-std)</h1>
<h4 data-number="10.0.0.1"
id="initialize-the-esp-gain-access-to-peripherals-3"><span
class="header-section-number">10.0.0.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>The initial step involves configuring the ESP device and gaining
access to its peripherals. This is achieved using the
<code>esp_hal::init</code> function, which sets up the device clocks and
initializes peripheral instances using the singleton pattern. This
ensures that only one instance of each peripheral is accessed throughout
the application, promoting safe and efficient hardware resource
management.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function takes an <code>esp_hal::Config</code>
struct as an argument and returns instances of the peripherals and
system clocks. Using the default configuration simplifies the setup
process by applying standard settings.</p>
<h4 data-number="10.0.0.2" id="create-an-io-driver-2"><span
class="header-section-number">10.0.0.2</span> Create an IO Driver</h4>
<p>With peripherals initialized, the next step is to create an IO
driver, which provides control over individual IO pins. The
<code>esp_hal::gpio</code> module offers the <code>Io</code> struct for
this purpose.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span></code></pre></div>
<p>This code initializes the IO driver by passing the GPIO and IO_MUX
peripherals obtained during initialization. The IO driver facilitates
further configuration and management of specific GPIO pins.</p>
<h4 data-number="10.0.0.3" id="configure-the-pwm-pin-into-output"><span
class="header-section-number">10.0.0.3</span> Configure the PWM Pin into
Output</h4>
<p>Before using a pin for PWM output, it must be configured as a
push-pull output. This configuration allows the microcontroller to
actively drive the pin high or low, enabling precise control over
connected devices.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> some_output_pin <span class="op">=</span> <span class="pp">Output::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio3<span class="op">,</span> <span class="pp">Level::</span>Low)<span class="op">;</span></span></code></pre></div>
<p>In this example, GPIO3 is set as an output with an initial low level.
The push-pull configuration ensures that the pin can actively drive both
high and low states, which is essential for generating PWM signals.</p>
<h4 data-number="10.0.0.4" id="create-an-ledc-peripheral-driver"><span
class="header-section-number">10.0.0.4</span> Create an LEDC Peripheral
Driver</h4>
<p>The LED Controller (LEDC) peripheral manages PWM signal generation.
Creating an LEDC driver involves instantiating the <code>Ledc</code>
struct and setting the global clock source.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new(</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    _instance<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> LEDC<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Self</span></span></code></pre></div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> ledc <span class="op">=</span> <span class="pp">Ledc::</span>new(peripherals<span class="op">.</span>LEDC)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb60"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>ledc<span class="op">.</span>set_global_slow_clock(<span class="pp">LSGlobalClkSource::</span>APBClk)<span class="op">;</span></span></code></pre></div>
<p>This code initializes the LEDC driver with the LEDC peripheral and
sets the global slow clock source to <code>APBClk</code>, which is
necessary for timing accuracy in PWM signal generation.</p>
<h4 data-number="10.0.0.5" id="configure-the-ledc-timer"><span
class="header-section-number">10.0.0.5</span> Configure the LEDC
Timer</h4>
<p>Timers are integral to PWM signal generation, determining the
frequency and resolution of the PWM signal. Configuring a timer involves
associating it with the LEDC instance and setting its parameters such as
duty resolution and frequency.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ledctimer <span class="op">=</span> ledc<span class="op">.</span><span class="pp">get_timer::</span><span class="op">&lt;</span>LowSpeed<span class="op">&gt;</span>(<span class="pp">ledc::timer::Number::</span>Timer0)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb62"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>ledctimer</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>configure(<span class="pp">timer::config::</span>Config <span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>        duty<span class="op">:</span> <span class="pp">timer::config::Duty::</span>Duty12Bit<span class="op">,</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>        clock_source<span class="op">:</span> <span class="pp">timer::LSClockSource::</span>APBClk<span class="op">,</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        frequency<span class="op">:</span> <span class="dv">4u32</span><span class="op">.</span>kHz()<span class="op">,</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, Timer0 is configured with a 12-bit duty resolution
and a frequency of 4 kHz. The <code>configure</code> method sets these
parameters, ensuring that the PWM signal operates at the desired
specifications.</p>
<h4 data-number="10.0.0.6" id="configure-a-pwm-channel-instance"><span
class="header-section-number">10.0.0.6</span> Configure a PWM Channel
Instance</h4>
<p>After configuring the timer, a PWM channel must be set up to generate
the PWM signal on a specific pin. This involves associating the output
pin with the PWM channel, linking it to the configured timer, and
setting the duty cycle.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> channel <span class="op">=</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    ledc<span class="op">.</span>get_channel(<span class="pp">channel::Number::</span>Channel0<span class="op">,</span> some_output_pin)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb64"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> S<span class="op">&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    S<span class="op">:</span> TimerSpeed<span class="op">,</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> timer<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">dyn</span> TimerIFace<span class="op">&lt;</span>S<span class="op">&gt;,</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> duty_pct<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> pin_config<span class="op">:</span> PinConfig<span class="op">,</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb65"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> channel0 <span class="op">=</span> ledc<span class="op">.</span>get_channel(<span class="pp">channel::Number::</span>Channel0<span class="op">,</span> led)<span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>channel0</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>configure(<span class="pp">channel::config::</span>Config <span class="op">{</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>        timer<span class="op">:</span> <span class="op">&amp;</span>ledctimer<span class="op">,</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        duty_pct<span class="op">:</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        pin_config<span class="op">:</span> <span class="pp">channel::config::PinConfig::</span>PushPull<span class="op">,</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This configuration associates Channel0 with the previously configured
Timer0 and sets the duty cycle to 10%. The
<code>PinConfig::PushPull</code> ensures that the pin can actively drive
the PWM signal.</p>
<h3 data-number="10.0.1" id="interacting-with-pwm-1"><span
class="header-section-number">10.0.1</span> Interacting with PWM</h3>
<p>Once PWM is configured, it can be controlled and monitored through
various methods provided by the LEDC driver.</p>
<h4 data-number="10.0.1.1"
id="controlling-the-ledc-pwm-peripheral-1"><span
class="header-section-number">10.0.1.1</span> Controlling the LEDC PWM
Peripheral</h4>
<p>PWM signals are primarily controlled by adjusting the duty cycle,
which determines the proportion of time the signal stays high versus low
within each cycle. This is managed using the <code>set_duty</code>
method.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Set the Desired Duty Cycle</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> set_duty(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> duty_pct<span class="op">:</span> <span class="dt">u8</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<p>This method allows the application to dynamically adjust the duty
cycle, enabling effects such as LED fading by smoothly transitioning
between different brightness levels.</p>
<h4 data-number="10.0.1.2"
id="reading-from-the-ledc-pwm-peripheral-1"><span
class="header-section-number">10.0.1.2</span> Reading from the LEDC PWM
Peripheral</h4>
<p>While PWM generation typically does not require reading from the
peripheral, certain applications may benefit from monitoring the current
state. The <code>max_duty_cycle</code> method can be used to retrieve
the maximum duty cycle value supported by the configuration.</p>
<h1 data-number="11" id="serial-communication-std"><span
class="header-section-number">11</span> Serial Communication (std)</h1>
<p>Serial communication is a method of transmitting data sequentially
over a single wire or a pair of wires, sending one bit at a time. This
contrasts with parallel communication, where multiple bits are
transmitted simultaneously across multiple channels. Serial
communication is favored in embedded systems, microcontrollers, and
various electronic devices due to its simplicity, reliability, and
efficiency. The two primary modes of serial communication are I2C
(Inter-Integrated Circuit) and SPI (Serial Peripheral Interface), each
with its own advantages. I2C is a synchronous protocol designed for
communication between microcontrollers and peripheral devices, offering
a smaller footprint but lower bandwidth compared to SPI. SPI, also
synchronous, is commonly used for short-distance communication between
microcontrollers and peripherals, providing higher speed and
bandwidth.</p>
<h3 data-number="11.0.1"
id="uart-universal-asynchronous-receivertransmitter"><span
class="header-section-number">11.0.1</span> UART (Universal Asynchronous
Receiver/Transmitter)</h3>
<p>UART stands for Universal Asynchronous Receiver/Transmitter and is a
widely used serial communication interface that transmits and receives
data asynchronously. This means that UART communication does not rely on
a shared clock signal between the transmitter and receiver. Instead,
both devices must agree on a specific baud rate—the number of bits
transmitted per second—to ensure accurate data transmission. UARTs are
prevalent in computers, microcontrollers, and embedded systems for
communicating with other devices or computers over serial connections.
In the ESP32-C3 microcontroller, UART is utilized for serial monitoring,
enabling functionalities such as the <code>println!()</code> macro for
debugging and logging.</p>
<p>A UART communication channel typically consists of two main
components: a transmitter and a receiver connected via a single wire for
each direction. The transmitter converts parallel data from the device
into a serial format, adding start and stop bits to indicate the
beginning and end of each data packet. The receiver then converts the
incoming serial data back into a parallel format for the device to
process. UART communication can operate in full-duplex mode, allowing
simultaneous transmission and reception of data using separate wires for
each direction, or in half-duplex mode, where data transmission and
reception occur alternately over a single wire.</p>
<h3 data-number="11.0.2" id="uart-configuration-parameters"><span
class="header-section-number">11.0.2</span> UART Configuration
Parameters</h3>
<p>For successful UART communication, both the transmitter and receiver
must have matching configurations. Key configuration options
include:</p>
<ul>
<li><p>Idle State: Determines the default state of the communication
line when no data is being transmitted. For example, if the idle state
is high, the receiver expects a transition from high to low to indicate
the start of a transmission.</p></li>
<li><p>Baud Rate: Specifies the number of bits transmitted per second.
Both devices must use the same baud rate to ensure data integrity.
Mismatched baud rates can lead to incorrect data sampling and
communication errors.</p></li>
<li><p>Data Bits: Defines the number of data bits per frame, commonly
set to 8 or 9 bits. The number of data bits must be consistent between
the transmitter and receiver.</p></li>
<li><p>Parity: An optional error-checking mechanism that can be set to
odd, even, or none. Parity helps detect errors in transmitted data by
adding an extra bit based on the number of set bits.</p></li>
<li><p>Stop Bits: Indicates the end of a data frame. UART frames
typically include one or two stop bits to mark the conclusion of data
transmission.</p></li>
<li><p>Flow Control: An optional feature that manages the rate of data
transmission to prevent buffer overflow. Hardware flow control uses
additional lines to signal the transmitter to pause or resume sending
data based on the receiver’s buffer status.</p></li>
</ul>
<h3 data-number="11.0.3"
id="asynchronous-vs.-synchronous-serial-communication"><span
class="header-section-number">11.0.3</span> Asynchronous vs. Synchronous
Serial Communication</h3>
<p>Serial communication can be categorized into asynchronous and
synchronous modes:</p>
<ol type="1">
<li><p>Asynchronous Serial Communication: In this mode, data is
transmitted without a shared clock signal between the sender and
receiver. Instead, both devices must agree on a baud rate to synchronize
data transmission. UART is a prime example of asynchronous
communication, relying on start and stop bits to frame data
packets.</p></li>
<li><p>Synchronous Serial Communication: This mode uses a shared clock
signal to synchronize data transmission between devices, eliminating the
need for start and stop bits. Synchronous protocols like SPI and I2C
rely on a common clock to ensure that data bits are transmitted and
received accurately and efficiently.</p></li>
</ol>
<h3 data-number="11.0.4"
id="common-serial-communication-protocols-in-embedded-systems"><span
class="header-section-number">11.0.4</span> Common Serial Communication
Protocols in Embedded Systems</h3>
<p>Several serial communication protocols are commonly employed in
embedded systems, each suited to different use cases based on their
characteristics:</p>
<ul>
<li><p>UART (Universal Asynchronous Receiver/Transmitter): A popular
asynchronous protocol used for point-to-point communication between
devices. UART is ideal for simple, low-speed data transmission tasks
such as debugging, logging, and interfacing with serial
peripherals.</p></li>
<li><p>I2C (Inter-Integrated Circuit): A synchronous protocol designed
for communication between multiple devices using only two wires (SDA for
data and SCL for clock). I2C is suitable for connecting sensors,
EEPROMs, and other low-speed peripherals to microcontrollers.</p></li>
<li><p>SPI (Serial Peripheral Interface): A high-speed synchronous
protocol that uses four wires (MOSI, MISO, SCLK, and SS) for
communication between a master device and one or more slave devices. SPI
is ideal for applications requiring faster data transfer rates, such as
interfacing with flash memory, displays, and high-speed
sensors.</p></li>
</ul>
<p>Serial communication is an essential method for data transmission in
embedded systems, offering various protocols tailored to different
application needs. UART, an asynchronous protocol, is widely used for
its simplicity and reliability in point-to-point communication,
particularly for debugging and interfacing with serial devices. Ensuring
that both transmitting and receiving devices share matching
configurations—such as baud rate, data bits, parity, and stop bits—is
crucial for successful UART communication. Additionally, understanding
the differences between asynchronous and synchronous serial
communication helps in selecting the appropriate protocol for specific
embedded applications, whether it’s the straightforward UART for simple
tasks or the high-speed SPI for more demanding data transfer
requirements.</p>
<h3 data-number="11.0.5" id="configuring-uart"><span
class="header-section-number">11.0.5</span> Configuring UART</h3>
<h4 data-number="11.0.5.1" id="take-the-peripherals-4"><span
class="header-section-number">11.0.5.1</span> Take the Peripherals</h4>
<p>The initial step in configuring UART is identical to previous
peripheral setups. This involves acquiring and initializing the
necessary peripherals required for UART operation to ensure they are
ready for configuration.</p>
<h4 data-number="11.0.5.2" id="configure-a-uart-instance"><span
class="header-section-number">11.0.5.2</span> Configure a UART
Instance</h4>
<p>To configure UART on the ESP32-C3, the <code>UartDriver</code>
abstraction from the <code>esp-idf-hal</code> library is utilized. The
<code>new</code> method of <code>UartDriver</code> is responsible for
creating a UART instance and requires six parameters:</p>
<ol type="1">
<li>uart: An instance of a UART peripheral.</li>
<li>tx: An output pin for transmitting serial bits.</li>
<li>rx: An input pin for receiving serial bits.</li>
<li>cts: (Optional) A pin for Clear To Send control flow.</li>
<li>rts: (Optional) A pin for Request To Send control flow.</li>
<li>config: A reference to a UART configuration.</li>
</ol>
<p>UartDriver <code>new</code> Method Signature</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new<span class="op">&lt;</span>UART<span class="op">:</span> Uart<span class="op">&gt;</span>(</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    uart<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> UART<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    tx<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> OutputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    rx<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> InputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    cts<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> InputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">&gt;,</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    rts<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> OutputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">&gt;,</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    config<span class="op">:</span> <span class="op">&amp;</span>Config</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>The <code>Config</code> struct for UART resides in the
<code>uart::config</code> module and includes several members to
fine-tune UART settings. While not all members need to be explicitly
configured, commonly used configurations like baud rate can be set using
the provided methods.</p>
<p>The <code>uart::config::Config</code> Configuration Struct</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> baudrate<span class="op">:</span> Hertz<span class="op">,</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> data_bits<span class="op">:</span> DataBits<span class="op">,</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> parity<span class="op">:</span> Parity<span class="op">,</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> stop_bits<span class="op">:</span> StopBits<span class="op">,</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> flow_control<span class="op">:</span> FlowControl<span class="op">,</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> flow_control_rts_threshold<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> source_clock<span class="op">:</span> SourceClock<span class="op">,</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> intr_flags<span class="op">:</span> EnumSet<span class="op">&lt;</span>InterruptType<span class="op">&gt;,</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> event_config<span class="op">:</span> EventConfig<span class="op">,</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> rx_fifo_size<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> tx_fifo_size<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> queue_size<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* private fields */</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Instantiating and Configuring <code>uart1</code> as 8N1 with 115200
Hz Baud and No Flow Control</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tx <span class="op">=</span> peripherals<span class="op">.</span>pins<span class="op">.</span>gpio5<span class="op">;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rx <span class="op">=</span> peripherals<span class="op">.</span>pins<span class="op">.</span>gpio6<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> config <span class="op">=</span> <span class="pp">config::Config::</span>new()<span class="op">.</span>baudrate(Hertz(<span class="dv">115_200</span>))<span class="op">;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart <span class="op">=</span> <span class="pp">UartDriver::</span>new(</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>uart1<span class="op">,</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    tx<span class="op">,</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    rx<span class="op">,</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Option</span><span class="pp">::</span><span class="op">&lt;</span><span class="pp">gpio::</span>Gpio0<span class="op">&gt;</span><span class="pp">::</span><span class="cn">None</span><span class="op">,</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Option</span><span class="pp">::</span><span class="op">&lt;</span><span class="pp">gpio::</span>Gpio1<span class="op">&gt;</span><span class="pp">::</span><span class="cn">None</span><span class="op">,</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>config<span class="op">,</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, <code>uart1</code> is instantiated with an 8N1
configuration (8 data bits, no parity, 1 stop bit) and a baud rate of
115200 Hz. Hardware flow control is disabled by setting <code>cts</code>
and <code>rts</code> to <code>None</code>. The <code>turbofish</code>
syntax (<code>::&lt;gpio::Gpio0&gt;</code>) assists the compiler in
inferring the correct types for the optional flow control pins.</p>
<h3 data-number="11.0.6" id="interacting-with-uart"><span
class="header-section-number">11.0.6</span> Interacting with UART</h3>
<h4 data-number="11.0.6.1" id="writing-to-the-uart-peripheral"><span
class="header-section-number">11.0.6.1</span> Writing to the UART
Peripheral</h4>
<p>To send data over UART, the <code>write</code> method of the
<code>UartDriver</code> is used. This method takes a slice of
<code>u8</code> data and transmits each byte sequentially.</p>
<p>Signature of <code>UartDriver</code> <code>write</code> Method</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> bytes<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>Example of Sending a Single Byte Over UART</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>some_uart_instance<span class="op">.</span>write(<span class="op">&amp;</span>[<span class="dv">25_u8</span>])<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This example sends a single byte with the value <code>25</code> over
the configured UART channel. The <code>write</code> method handles the
conversion of parallel data to serial format and manages the
transmission of bits.</p>
<h4 data-number="11.0.6.2"
id="blocking-read-from-the-uart-peripheral"><span
class="header-section-number">11.0.6.2</span> Blocking Read from the
UART Peripheral</h4>
<p>Receiving data over UART involves using the <code>read</code> method,
which performs a blocking read operation. This means the code will wait
(block) until the specified number of bytes are received or the timeout
is reached.</p>
<p>Signature of <code>UartDriver</code> <code>read</code> Method</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> read(</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]<span class="op">,</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    timeout<span class="op">:</span> TickType_t</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>Example of Receiving a Single Byte Over UART</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> buf <span class="op">=</span> [<span class="dv">0_u8</span><span class="op">;</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">// BLOCK is a constant containing the largest possible u32 value</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>some_uart_instance<span class="op">.</span>read(<span class="op">&amp;</span><span class="kw">mut</span> buf<span class="op">,</span> BLOCK)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, the <code>read</code> method attempts to receive a
single byte and stores it in <code>buf</code>. The <code>BLOCK</code>
constant ensures that the method waits indefinitely until data is
received.</p>
<h3 data-number="11.0.7" id="configuring-i2c"><span
class="header-section-number">11.0.7</span> Configuring I2C</h3>
<h4 data-number="11.0.7.1" id="take-the-peripherals-5"><span
class="header-section-number">11.0.7.1</span> Take the Peripherals</h4>
<p>Similar to UART configuration, the first step in setting up I2C
involves taking and initializing the necessary peripherals as
demonstrated before.</p>
<h4 data-number="11.0.7.2"
id="create-and-configure-an-i2c-instance"><span
class="header-section-number">11.0.7.2</span> Create and Configure an
I2C Instance</h4>
<p>The <code>I2cDriver</code> abstraction from the
<code>esp-idf-hal</code> library is used to create and configure an I2C
instance. The <code>new</code> method requires four parameters:</p>
<ol type="1">
<li>i2c: An instance of an I2C peripheral.</li>
<li>sda: A bidirectional pin instance for the Serial Data Line.</li>
<li>scl: A bidirectional pin instance for the Serial Clock Line.</li>
<li>config: A reference to an I2C configuration.</li>
</ol>
<p>I2cDriver <code>new</code> Method Signature</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new<span class="op">&lt;</span>I2C<span class="op">:</span> I2c<span class="op">&gt;</span>(</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    _i2c<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> I2C<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    sda<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> InputPin <span class="op">+</span> OutputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    scl<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> <span class="kw">impl</span> InputPin <span class="op">+</span> OutputPin<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    config<span class="op">:</span> <span class="op">&amp;</span>Config</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>The <code>Config</code> struct for I2C is defined in the
<code>i2c::config</code> module and includes various parameters to
tailor the I2C communication settings.</p>
<p>The <code>i2c::config::Config</code> Configuration Struct</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> baudrate<span class="op">:</span> Hertz<span class="op">,</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> sda_pullup_enabled<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> scl_pullup_enabled<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> timeout<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>APBTickType<span class="op">&gt;,</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> intr_flags<span class="op">:</span> EnumSet<span class="op">&lt;</span>InterruptType<span class="op">&gt;,</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>*Example of Instantiating and Configuring an I2C Channel Using the
<code>i2c0</code> Peripheral</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i2c_instance <span class="op">=</span> peripherals<span class="op">.</span>i2c0<span class="op">;</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> config <span class="op">=</span> <span class="pp">I2cConfig::</span>new()<span class="op">.</span>baudrate(<span class="dv">100</span><span class="op">.</span>kHz()<span class="op">.</span>into())<span class="op">;</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i2c_driver <span class="op">=</span> <span class="pp">I2cDriver::</span>new(i2c<span class="op">,</span> sda<span class="op">,</span> scl<span class="op">,</span> <span class="op">&amp;</span>config)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This example configures the <code>i2c0</code> peripheral with a baud
rate of 100 kHz. The <code>I2cDriver::new</code> method initializes the
I2C instance with the specified SDA and SCL pins and the provided
configuration.</p>
<h3 data-number="11.0.8" id="interacting-with-i2c"><span
class="header-section-number">11.0.8</span> Interacting with I2C</h3>
<h4 data-number="11.0.8.1" id="writing-to-the-i2c-peripheral"><span
class="header-section-number">11.0.8.1</span> Writing to the I2C
Peripheral</h4>
<p>To send data over I2C, the <code>write</code> method of the
<code>I2cDriver</code> is utilized. This method requires the slave
address, a slice of <code>u8</code> data to send, and a timeout
value.</p>
<p>Signature of <code>I2cDriver</code> <code>write</code> Method</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> write(</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    addr<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    bytes<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]<span class="op">,</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    timeout<span class="op">:</span> TickType_t</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>Example of Sending a Single Byte Over I2C to Address 0x65</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">// BLOCK is a constant containing the largest possible u32 value</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>some_i2c_instance<span class="op">.</span>write(<span class="dv">0x65</span><span class="op">,</span> <span class="op">&amp;</span>[<span class="dv">25</span>]<span class="op">,</span> BLOCK)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, a single byte with the value <code>25</code> is sent
to the I2C slave device with the address <code>0x65</code>. The
<code>BLOCK</code> constant ensures that the method waits until the
write operation is completed.</p>
<h4 data-number="11.0.8.2" id="reading-from-the-i2c-peripheral"><span
class="header-section-number">11.0.8.2</span> Reading from the I2C
Peripheral</h4>
<p>Receiving data over I2C involves using the <code>read</code> method,
which retrieves data from a specified slave address into a provided
buffer within a given timeout period.</p>
<p>Signature of <code>I2cDriver</code> <code>read</code> Method</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> read(</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    addr<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    buffer<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]<span class="op">,</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    timeout<span class="op">:</span> TickType_t</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> EspError<span class="op">&gt;</span></span></code></pre></div>
<p>Example of Receiving a Single Byte Over I2C from Address 0x65</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> buf <span class="op">=</span> [<span class="dv">0_u8</span><span class="op">;</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">// BLOCK is a constant containing the largest possible u32 value</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>some_i2c_instance<span class="op">.</span>read(<span class="dv">0x65</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> buf<span class="op">,</span> BLOCK)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>This example demonstrates how to receive a single byte from the I2C
slave device at address <code>0x65</code>. The received byte is stored
in the <code>buf</code> array, and the operation blocks until the data
is received or the timeout is reached.</p>
<p>Configuring UART and I2C on the ESP32-C3 involves initializing the
necessary peripherals, creating and configuring driver instances with
appropriate settings, and utilizing provided methods to handle data
transmission and reception. For UART, this includes setting parameters
like baud rate, data bits, parity, and stop bits, and managing transmit
and receive operations using the <code>write</code> and
<code>read</code> methods. For I2C, configuration involves setting the
baud rate, enabling pull-ups, and handling communication with slave
devices through <code>write</code> and <code>read</code> methods that
require specifying slave addresses and managing timeouts. By following
the provided steps and utilizing the code examples, developers can
effectively implement robust serial communication in their embedded
applications.</p>
<h1 data-number="12" id="serial-communication-no-std"><span
class="header-section-number">12</span> Serial Communication
(no-std)</h1>
<h4 data-number="12.0.0.1"
id="initialize-the-esp-gain-access-to-peripherals-4"><span
class="header-section-number">12.0.0.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>Before utilizing any device peripherals, it’s crucial to configure
the ESP device itself. This involves setting up the device clocks and
gaining access to peripheral instances using the singleton pattern. The
<code>esp-hal</code> crate provides a streamlined method for
initializing the device with default configurations.</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function takes an <code>esp_hal::Config</code>
struct as an argument and returns instances of the peripherals and
system clocks. Using the default configuration simplifies the setup
process by applying standard settings, ensuring that the device is ready
for peripheral configuration.</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> cpu_clock<span class="op">:</span> CpuClock<span class="op">,</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> watchdog<span class="op">:</span> WatchdogConfig<span class="op">,</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>Config</code> struct allows customization of system
parameters such as CPU clock speed and watchdog settings. However, for
basic applications, the default values are typically sufficient, as
demonstrated in the initialization step.</p>
<h4 data-number="12.0.0.2" id="create-an-io-driver-3"><span
class="header-section-number">12.0.0.2</span> Create an IO Driver</h4>
<p>With peripherals initialized, the next step is to create an IO
driver. The IO driver provides control over individual IO pins, enabling
their configuration for various functions, including UART
communication.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span></code></pre></div>
<p>This code initializes the IO driver by passing the GPIO and IO_MUX
peripherals obtained during initialization. The IO driver facilitates
further configuration and management of specific GPIO pins required for
UART operations.</p>
<h4 data-number="12.0.0.3" id="instantiate-uart-pins"><span
class="header-section-number">12.0.0.3</span> Instantiate UART Pins</h4>
<p>Before creating a UART instance, the pins designated for UART
communication must be instantiated. Typically, the transmit (TX) pin is
configured as an output, and the receive (RX) pin is configured as an
input. This configuration ensures proper data transmission and
reception.</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure GPIO21 as UART TX (Output)</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart_tx <span class="op">=</span> <span class="pp">Output::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio21<span class="op">,</span> <span class="pp">Level::</span>Low)<span class="op">;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure GPIO20 as UART RX (Input with Pull-Up)</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart_rx <span class="op">=</span> <span class="pp">Input::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio20<span class="op">,</span> <span class="pp">Pull::</span>Up)<span class="op">;</span></span></code></pre></div>
<p>In this example: - GPIO21 is configured as an output pin for
transmitting data. - GPIO20 is configured as an input pin with a pull-up
resistor for receiving data.</p>
<h4 data-number="12.0.0.4" id="configure-a-uart-instance-1"><span
class="header-section-number">12.0.0.4</span> Configure a UART
Instance</h4>
<p>Configuring UART involves creating a UART instance with specific
settings such as baud rate, data bits, parity, stop bits, and clock
source. The <code>esp_hal::uart::Uart</code> abstraction provides
methods to instantiate and configure UART peripherals effectively.</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new_with_config<span class="op">&lt;</span>TX<span class="op">:</span> OutputPin<span class="op">,</span> RX<span class="op">:</span> InputPin<span class="op">&gt;</span>(</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    uart<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> T<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    config<span class="op">:</span> Config<span class="op">,</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    tx<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> TX<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    rx<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> RX<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">Self</span><span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb86"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">struct</span> Config <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> baudrate<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> data_bits<span class="op">:</span> DataBits<span class="op">,</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> parity<span class="op">:</span> Parity<span class="op">,</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> stop_bits<span class="op">:</span> StopBits<span class="op">,</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> clock_source<span class="op">:</span> ClockSource<span class="op">,</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> rx_fifo_full_threshold<span class="op">:</span> <span class="dt">u16</span><span class="op">,</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> rx_timeout<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;,</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb87"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a UART Configuration</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart_config <span class="op">=</span> Config <span class="op">{</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    baudrate<span class="op">:</span> <span class="dv">115200</span><span class="op">,</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>    data_bits<span class="op">:</span> <span class="pp">DataBits::</span>DataBits8<span class="op">,</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    parity<span class="op">:</span> <span class="pp">Parity::</span>ParityNone<span class="op">,</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    stop_bits<span class="op">:</span> <span class="pp">StopBits::</span>STOP1<span class="op">,</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    clock_source<span class="op">:</span> <span class="pp">ClockSource::</span>Apb<span class="op">,</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">..</span><span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()</span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb88"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> log <span class="op">=</span> <span class="pp">Uart::</span>new_with_config(</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>UART0<span class="op">,</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    uart_config<span class="op">,</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio21<span class="op">,</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio20<span class="op">,</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example: 1. UART Configuration: An instance of
<code>Config</code> is created with the following settings: - Baud Rate:
115200 - Data Bits: 8 - Parity: None - Stop Bits: 1 - Clock Source: APB
Clock 2. UART Instantiation: A new UART instance (<code>log</code>) is
created using the <code>UART0</code> peripheral, the defined
configuration, and the instantiated TX (<code>gpio21</code>) and RX
(<code>gpio20</code>) pins. The <code>unwrap()</code> method is used to
handle any potential errors during instantiation, assuming successful
configuration.</p>
<p>Note: <code>UART0</code> is typically used for logging and firmware
communication on ESP32-C3 development boards. For UART operations
intended for other purposes, it’s advisable to consult the device’s
reference manual to ensure correct peripheral usage and pin
assignments.</p>
<h4 data-number="12.0.0.5" id="interacting-with-uart-1"><span
class="header-section-number">12.0.0.5</span> Interacting with UART</h4>
<p>Once the UART instance is configured, it can be used to send and
receive data. The <code>Uart</code> type offers several methods to
facilitate standard write and read operations.</p>
<h5 data-number="12.0.0.5.1" id="writing-to-the-uart-peripheral-1"><span
class="header-section-number">12.0.0.5.1</span> Writing to the UART
Peripheral</h5>
<p>Sending data over UART is accomplished through write operations. The
<code>write_bytes</code> method allows sending a slice of bytes over the
UART channel.</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> write_bytes(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> data<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb90"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>some_uart_instance<span class="op">.</span>write_bytes(<span class="op">&amp;</span>[<span class="dv">25_u8</span>])<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, a single byte with the value <code>25</code> is sent
over the UART channel. The <code>unwrap()</code> method ensures that the
operation succeeds, and any errors during the write process will cause a
panic. For robust applications, consider handling errors gracefully
instead of using <code>unwrap()</code>.</p>
<h5 data-number="12.0.0.5.2"
id="blocking-read-from-the-uart-peripheral-1"><span
class="header-section-number">12.0.0.5.2</span> Blocking Read from the
UART Peripheral</h5>
<p>Receiving data over UART involves read operations. The blocking read
approach waits until data is available before proceeding, ensuring that
the application receives the intended data.</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">,</span> <span class="dt">Self</span><span class="pp">::</span><span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb92"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> buf <span class="op">=</span> [<span class="dv">0_u8</span><span class="op">;</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>some_uart_instance<span class="op">.</span>read(<span class="op">&amp;</span><span class="kw">mut</span> buf)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example: 1. Buffer Initialization: A mutable buffer
<code>buf</code> is created to store the received byte. 2. Read
Operation: The <code>read</code> method is called on the UART instance,
attempting to read one byte into the buffer. The <code>unwrap()</code>
method is used to handle any potential errors, assuming successful data
reception.</p>
<p>Note: The blocking read approach may halt the execution of other
tasks until data is received. For applications requiring concurrent
operations, consider implementing non-blocking reads or utilizing
asynchronous programming techniques.</p>
<h3 data-number="12.0.1" id="configuring-i2c-on-esp-devices"><span
class="header-section-number">12.0.1</span> Configuring I2C on ESP
Devices</h3>
<p>Configuring the Inter-Integrated Circuit (I2C) interface on ESP
devices using Rust involves a systematic process that ensures reliable
serial communication with various I2C peripherals. I2C is widely used
for connecting low-speed peripherals like sensors, displays, and EEPROMs
to microcontrollers. This guide outlines the necessary steps to
initialize the ESP device, set up the IO driver, configure I2C pins,
instantiate and configure an I2C instance, and interact with the I2C
peripheral for data transmission and reception.</p>
<h4 data-number="12.0.1.1"
id="initialize-the-esp-gain-access-to-peripherals-5"><span
class="header-section-number">12.0.1.1</span> Initialize the ESP &amp;
Gain Access to Peripherals</h4>
<p>The initial step involves configuring the ESP device and gaining
access to its peripherals. This is achieved using the
<code>esp_hal::init</code> function, which sets up the device clocks and
initializes peripheral instances using the singleton pattern. This
ensures that only one instance of each peripheral is accessed throughout
the application, promoting safe and efficient hardware resource
management.</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> device_peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span></code></pre></div>
<p>The <code>init</code> function takes an <code>esp_hal::Config</code>
struct as an argument and returns instances of the peripherals and
system clocks. Using the default configuration simplifies the setup
process by applying standard settings, ensuring that the device is ready
for peripheral configuration.</p>
<h4 data-number="12.0.1.2" id="create-an-io-driver-4"><span
class="header-section-number">12.0.1.2</span> Create an IO Driver</h4>
<p>With peripherals initialized, the next step is to create an IO
driver. The IO driver provides control over individual IO pins, enabling
their configuration for various functions, including I2C
communication.</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> io <span class="op">=</span> <span class="pp">Io::</span>new(peripherals<span class="op">.</span>GPIO<span class="op">,</span> peripherals<span class="op">.</span>IO_MUX)<span class="op">;</span></span></code></pre></div>
<p>This code initializes the IO driver by passing the GPIO and IO_MUX
peripherals obtained during initialization. The IO driver facilitates
further configuration and management of specific GPIO pins required for
I2C operations.</p>
<h4 data-number="12.0.1.3"
id="create-and-configure-an-i2c-instance-1"><span
class="header-section-number">12.0.1.3</span> Create and Configure an
I2C Instance</h4>
<p>Configuring I2C involves creating an I2C instance with specific
settings such as the operating frequency and associating it with
designated SDA (Serial Data) and SCL (Serial Clock) pins. The
<code>esp_hal::i2c::I2c</code> abstraction provides methods to
instantiate and configure I2C peripherals effectively.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new<span class="op">&lt;</span>SDA<span class="op">:</span> OutputPin <span class="op">+</span> InputPin<span class="op">,</span> SCL<span class="op">:</span> OutputPin <span class="op">+</span> InputPin<span class="op">&gt;</span>(</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    i2c<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> T<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    sda<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> SDA<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    scl<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> SCL<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    frequency<span class="op">:</span> HertzU32<span class="op">,</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Self</span></span></code></pre></div>
<div class="sourceCode" id="cb96"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i2c <span class="op">=</span> <span class="pp">I2c::</span>new(</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>I2C0<span class="op">,</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio1<span class="op">,</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio2<span class="op">,</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100u32</span><span class="op">.</span>kHz()<span class="op">,</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>In this example: 1. I2C Peripheral Instance:
<code>peripherals.I2C0</code> refers to the I2C0 peripheral instance
obtained during initialization. 2. SDA and SCL Pins:
<code>io.pins.gpio1</code> and <code>io.pins.gpio2</code> are
instantiated as bidirectional pins for SDA and SCL respectively. 3.
Frequency: The I2C operation frequency is set to 100 kHz, which is a
standard speed for I2C communication.</p>
<h4 data-number="12.0.1.4" id="instantiate-uart-pins-1"><span
class="header-section-number">12.0.1.4</span> Instantiate UART Pins</h4>
<p>Before creating a UART instance, the pins designated for UART
communication must be instantiated. Typically, the transmit (TX) pin is
configured as an output, and the receive (RX) pin is configured as an
input. This configuration ensures proper data transmission and
reception.</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure GPIO21 as UART TX (Output)</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart_tx <span class="op">=</span> <span class="pp">Output::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio21<span class="op">,</span> <span class="pp">Level::</span>Low)<span class="op">;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Configure GPIO20 as UART RX (Input with Pull-Up)</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> uart_rx <span class="op">=</span> <span class="pp">Input::</span>new(io<span class="op">.</span>pins<span class="op">.</span>gpio20<span class="op">,</span> <span class="pp">Pull::</span>Up)<span class="op">;</span></span></code></pre></div>
<p>In this example: - GPIO21 is configured as an output pin for
transmitting data. - GPIO20 is configured as an input pin with a pull-up
resistor for receiving data.</p>
<h4 data-number="12.0.1.5" id="configure-an-i2c-instance"><span
class="header-section-number">12.0.1.5</span> Configure an I2C
Instance</h4>
<p>Configuring I2C involves creating an I2C instance with specific
settings such as the operating frequency and associating it with
designated SDA (Serial Data) and SCL (Serial Clock) pins.</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> new<span class="op">&lt;</span>SDA<span class="op">:</span> OutputPin <span class="op">+</span> InputPin<span class="op">,</span> SCL<span class="op">:</span> OutputPin <span class="op">+</span> InputPin<span class="op">&gt;</span>(</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    i2c<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> T<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    sda<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> SDA<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    scl<span class="op">:</span> <span class="kw">impl</span> Peripheral<span class="op">&lt;</span>P <span class="op">=</span> SCL<span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;d</span><span class="op">,</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    frequency<span class="op">:</span> HertzU32<span class="op">,</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Self</span></span></code></pre></div>
<div class="sourceCode" id="cb99"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i2c <span class="op">=</span> <span class="pp">I2c::</span>new(</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    peripherals<span class="op">.</span>I2C0<span class="op">,</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio1<span class="op">,</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>pins<span class="op">.</span>gpio2<span class="op">,</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">100u32</span><span class="op">.</span>kHz()<span class="op">,</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>In this example: 1. I2C Peripheral Instance:
<code>peripherals.I2C0</code> refers to the I2C0 peripheral instance
obtained during initialization. 2. SDA and SCL Pins:
<code>io.pins.gpio1</code> and <code>io.pins.gpio2</code> are
instantiated as bidirectional pins for SDA and SCL respectively. 3.
Frequency: The I2C operation frequency is set to 100 kHz, which is a
standard speed for I2C communication.</p>
<h4 data-number="12.0.1.6" id="interacting-with-i2c-1"><span
class="header-section-number">12.0.1.6</span> Interacting with I2C</h4>
<p>Once the I2C instance is configured, it can be used to send and
receive data to and from I2C devices. The <code>I2c</code> type
implements the <code>embedded_io::Write</code> and
<code>embedded_io::Read</code> traits, facilitating standard write and
read operations.</p>
<h5 data-number="12.0.1.6.1" id="writing-to-the-i2c-peripheral-1"><span
class="header-section-number">12.0.1.6.1</span> Writing to the I2C
Peripheral</h5>
<p>Sending data over I2C is accomplished through write operations. The
<code>write</code> method allows sending a slice of bytes to a specific
I2C slave address.</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> write(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> addr<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span> bytes<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb101"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>some_i2c_instance<span class="op">.</span>write(<span class="dv">0x65</span><span class="op">,</span> <span class="op">&amp;</span>[<span class="dv">25</span>])<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example, a single byte with the value <code>25</code> is sent
to the I2C slave device with the address <code>0x65</code>. The
<code>unwrap()</code> method is used to handle any potential errors
during the write process, assuming successful transmission.</p>
<h5 data-number="12.0.1.6.2"
id="reading-from-the-i2c-peripheral-1"><span
class="header-section-number">12.0.1.6.2</span> Reading from the I2C
Peripheral</h5>
<p>Receiving data over I2C involves read operations. The
<code>read</code> method allows reading a specified number of bytes from
a particular I2C slave address into a buffer.</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> read(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> address<span class="op">:</span> <span class="dt">u8</span><span class="op">,</span> buffer<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="bu">Error</span><span class="op">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb103"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> buf <span class="op">=</span> [<span class="dv">0_u8</span><span class="op">;</span> <span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>some_i2c_instance<span class="op">.</span>read(<span class="dv">0x65</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> buf)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>In this example: 1. Buffer Initialization: A mutable buffer
<code>buf</code> is created to store the received byte. 2. Read
Operation: The <code>read</code> method is called on the I2C instance,
attempting to read one byte from the I2C slave device at address
<code>0x65</code> into the buffer. The <code>unwrap()</code> method is
used to handle any potential errors, assuming successful data
reception.</p>
<h1 data-number="13" id="iot-networking-services-std"><span
class="header-section-number">13</span> IoT &amp; Networking Services
(std)</h1>
<p>ESP devices have gained popularity for their robust connectivity and
Internet of Things (IoT) capabilities, supported by both software and
hardware innovations. In the Rust programming environment, the
<code>esp-idf-svc</code> and <code>embedded-svc</code> crates provide
comprehensive support for a wide range of networking services, including
WiFi, Ethernet, HTTP client &amp; server, MQTT, WebSockets (WS), Network
Time Protocol (NTP), and Over-The-Air (OTA) updates. Establishing
network access is a fundamental step for any IoT service, with WiFi
being a common protocol used for this purpose. This section introduces
the basics of programming WiFi, focusing on establishing a simple
connection rather than delving into intricate configuration details, to
maintain clarity and avoid code verbosity.</p>
<h3 data-number="13.0.1" id="wifi"><span
class="header-section-number">13.0.1</span> WiFi</h3>
<p>WiFi, short for Wireless Fidelity, enables wireless connections
between devices within a local network using radio waves. Devices can
function as either clients or access points, with access points acting
as central hubs connected to wired networks to extend wireless
connectivity. WiFi operates primarily in the 2.4 GHz and 5 GHz frequency
bands. The 2.4 GHz band offers wider coverage and better obstacle
penetration but is more prone to congestion. In contrast, the 5 GHz band
provides faster data rates and more reliable connections in crowded
environments, albeit with a shorter range and reduced penetration
capabilities. Security in WiFi networks is maintained through encryption
protocols like WPA2 and WPA3, ensuring data privacy and preventing
unauthorized access. Once connected, devices can communicate seamlessly
and access network resources without the limitations of physical cables.
The ESP32-C3 microcontroller is equipped with advanced WiFi
functionalities, offering four virtual interfaces: Station (STA), Access
Point (AP), Sniffer, and a reserved interface. It supports multiple
operational modes, including Station-only, AP-only, and coexistence
modes, adhering to IEEE 802.11 b/g/n standards. Security features
include support for WPA2 and WPA3 protocols. Additionally, the ESP32-C3
uniquely incorporates the ESP-NOW protocol and a Long Range mode,
enabling extended data transmission distances of up to 1 kilometer.
These capabilities make the ESP32-C3 a versatile choice for a wide range
of IoT applications requiring reliable and secure wireless
communication.</p>
<h3 data-number="13.0.2" id="configuring-wifi"><span
class="header-section-number">13.0.2</span> Configuring WiFi</h3>
<p>This section outlines the process of configuring WiFi for ESP devices
using Rust. It emphasizes the importance of establishing network access
as a foundational step for any IoT service, with WiFi being a primary
protocol for connectivity. The focus is on creating a basic WiFi
connection without delving into complex configuration details to
maintain simplicity and avoid excessive code complexity. The section
also highlights the use of the <code>esp-idf-svc</code> and
<code>embedded-svc</code> crates for managing various networking
services.</p>
<h3 data-number="13.0.3" id="the-anyhow-crate"><span
class="header-section-number">13.0.3</span> The AnyHow Crate</h3>
<p>The AnyHow crate is introduced as a solution to improve error
handling in Rust applications for ESP devices. Traditionally, the
<code>unwrap</code> method was used to extract values from
<code>Result</code> types, which can lead to panics if an error occurs.
The AnyHow crate integrates ESP-IDF error codes, providing more
informative error messages and better context for debugging. To use
AnyHow, developers need to declare it as a dependency, import it, change
the main function’s return type to <code>anyhow::Result</code>, and
replace <code>unwrap</code> calls with the <code>?</code> operator. This
approach enhances the robustness and maintainability of the code,
especially in wireless implementations.</p>
<h3 data-number="13.0.4" id="take-the-peripherals-6"><span
class="header-section-number">13.0.4</span> Take the Peripherals</h3>
<p>The first step in configuring WiFi involves taking control of the
device’s peripherals. This is done using the
<code>Peripherals::take().unwrap()</code> method, which initializes the
necessary hardware components required for WiFi functionality. This step
is consistent with earlier sections of the documentation, ensuring that
the peripherals are properly initialized before proceeding to create and
configure the WiFi driver instance.</p>
<h3 data-number="13.0.5" id="create-a-wifi-driver-instance"><span
class="header-section-number">13.0.5</span> Create a WiFi Driver
Instance</h3>
<p>Creating a WiFi driver instance involves using the
<code>esp-idf-svc</code> crate, which offers multiple structures such as
<code>EspWifi</code> and <code>WifiDriver</code>. The
<code>EspWifi</code> struct provides a higher-level abstraction,
simplifying the creation of networking examples by encapsulating a
<code>WifiDriver</code>. To instantiate <code>EspWifi</code>, developers
use the <code>new</code> method, which requires a WiFi peripheral
instance, a system event loop, and an optional non-volatile storage
(NVS) partition. This setup follows a singleton pattern, ensuring that
only one instance of each component is created.</p>
<h3 data-number="13.0.6" id="configure-the-wifi-driver-instance"><span
class="header-section-number">13.0.6</span> Configure the WiFi Driver
Instance</h3>
<p>Once the WiFi driver instance is created, it needs to be configured
to operate either in station mode or access point mode. Station mode
allows the device to connect to an existing WiFi network as a client,
while access point mode enables the device to act as a hotspot for other
clients to connect. The <code>set_configuration</code> method of
<code>EspWifi</code> is used to apply the desired configuration by
passing a <code>Configuration</code> enum. For example, configuring the
device as a client involves specifying the SSID, password, and
authentication method. This step is crucial for establishing the desired
network behavior of the ESP device.</p>
<h3 data-number="13.0.7" id="interacting-with-wifi"><span
class="header-section-number">13.0.7</span> Interacting with WiFi</h3>
<p>Interacting with the WiFi subsystem involves managing connections and
monitoring the status of the network interface. The ESP-IDF framework
supports both blocking and non-blocking operations, with the example
focusing on a blocking approach for simplicity. By wrapping the
<code>EspWifi</code> instance with a <code>BlockingWifi</code>
abstraction, developers can perform operations such as starting the
WiFi, connecting to a network, and waiting for the network interface to
become active. Additionally, the framework provides methods like
<code>is_connected</code> and <code>get_configuration</code> to check
the connection status and retrieve current network settings,
respectively.</p>
<h3 data-number="13.0.8" id="connecting-to-wifi"><span
class="header-section-number">13.0.8</span> Connecting to WiFi</h3>
<p>Connecting to a WiFi network involves a sequence of method calls on
the <code>BlockingWifi</code> instance. First, the <code>start</code>
method initializes the WiFi peripheral. Next, the <code>connect</code>
method attempts to establish a connection to the specified network using
the previously set configuration. Finally, the
<code>wait_netif_up</code> method blocks the execution until the network
interface is fully up and running. Each of these methods returns a
<code>Result</code>, ensuring that any issues during the connection
process are appropriately handled and propagated.</p>
<h3 data-number="13.0.9" id="reading-wifi-status"><span
class="header-section-number">13.0.9</span> Reading WiFi Status</h3>
<p>Monitoring the WiFi status is essential for ensuring a stable and
reliable network connection. The <code>EspWifi</code> struct provides
methods such as <code>is_connected</code> to check if the device is
currently connected to a WiFi network and <code>get_configuration</code>
to retrieve the current network settings. These methods return results
that can be used to verify the connection status and debug any issues
related to network configuration. While <code>EspWifi</code> offers a
wide range of methods for controlling and monitoring the WiFi instance,
this section focuses on the essential functions necessary for achieving
and maintaining network connectivity.</p>
<h3 data-number="13.0.10" id="http-client"><span
class="header-section-number">13.0.10</span> HTTP Client</h3>
<p>HTTP (Hypertext Transfer Protocol) is the cornerstone of internet
communication, operating on a client-server model that enables data
exchange between web browsers and servers. When a user enters a website
URL, the browser initiates an HTTP request—commonly a GET request—to the
server hosting the desired website. This request specifies actions such
as fetching a webpage or submitting data and utilizes methods like GET,
POST, PUT, and DELETE to define its purpose. HTTP relies on the TCP
protocol for data transmission and includes headers that provide
additional information about the request and response. Upon receiving a
request, the server processes it and responds with a status code (e.g.,
200 for success, 404 for not found) and the requested data. HTTP is
inherently stateless, treating each request independently, which can
make data vulnerable to interception. To enhance security, HTTPS
encrypts the data transmitted between clients and servers, ensuring
secure communication. A typical GET request workflow involves
establishing a TCP connection, sending the GET request with necessary
headers, the server processing and responding with the appropriate
status code and data, the client rendering the response, and finally
closing the connection. Understanding HTTP client interactions is
essential for developing robust and secure IoT applications that
communicate effectively over the internet.</p>
<h3 data-number="13.0.11" id="configuring-an-http-client"><span
class="header-section-number">13.0.11</span> Configuring an HTTP
Client</h3>
<p>Configuring an HTTP client for ESP devices using Rust involves a
systematic approach that ensures secure and efficient communication over
the internet. This process leverages the <code>esp-idf-svc</code> crate,
which provides essential abstractions for handling HTTP client
functionalities within the ESP-IDF framework. The configuration process
is divided into several key steps, each building upon the previous to
establish a robust HTTP client setup.</p>
<h4 data-number="13.0.11.1" id="take-the-peripherals-7"><span
class="header-section-number">13.0.11.1</span> Take the Peripherals</h4>
<p>The initial step in configuring an HTTP client mirrors the process
used in setting up WiFi. It involves taking control of the device’s
peripherals using the <code>Peripherals::take().unwrap()</code> method.
This ensures that all necessary hardware components are properly
initialized and ready for subsequent configuration steps. By securing
access to the peripherals, the device can effectively manage networking
tasks required for HTTP communication.</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<h4 data-number="13.0.11.2" id="connect-to-wifi"><span
class="header-section-number">13.0.11.2</span> Connect to WiFi</h4>
<p>Before establishing an HTTP connection, the device must be connected
to a WiFi network. This step is identical to the WiFi configuration
process outlined earlier, where the device is set up either as a station
or an access point. Successfully connecting to WiFi provides the
necessary network access for the HTTP client to send and receive data
over the internet.</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sysloop <span class="op">=</span> <span class="pp">EspSystemEventLoop::</span>take()<span class="op">?;</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> nvs <span class="op">=</span> <span class="pp">EspDefaultNvsPartition::</span>take()<span class="op">?;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wifi <span class="op">=</span> <span class="pp">EspWifi::</span>new(peripherals<span class="op">.</span>modem<span class="op">,</span> sysloop<span class="op">,</span> <span class="cn">Some</span>(nvs))<span class="op">?;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>set_configuration(<span class="op">&amp;</span><span class="pp">Configuration::</span>Client(ClientConfiguration <span class="op">{</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    ssid<span class="op">:</span> <span class="st">&quot;SSID&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    password<span class="op">:</span> <span class="st">&quot;PASSWORD&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    auth_method<span class="op">:</span> <span class="pp">AuthMethod::</span><span class="cn">None</span><span class="op">,</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">..</span><span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>))<span class="op">?;</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>start()<span class="op">?;</span></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>connect()<span class="op">?;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>wait_netif_up()<span class="op">?;</span></span></code></pre></div>
<h4 data-number="13.0.11.3" id="configure-an-http-connection"><span
class="header-section-number">13.0.11.3</span> Configure an HTTP
Connection</h4>
<p>Configuring an HTTP connection involves creating an instance of
<code>EspHttpConnection</code> from the
<code>esp_idf_svc::http::client</code> module. This abstraction requires
a reference to a <code>http::client::Configuration</code> struct during
instantiation. The configuration typically sets essential parameters
such as <code>use_global_ca_store</code> and
<code>crt_bundle_attach</code> to enable secure HTTPS connections. These
settings ensure that the HTTP client uses a global certificate authority
store and attaches the necessary certificate bundle for encryption,
which is crucial for secure data transmission.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> httpconnection <span class="op">=</span> <span class="pp">EspHttpConnection::</span>new(<span class="op">&amp;</span>Configuration <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    use_global_ca_store<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    crt_bundle_attach<span class="op">:</span> <span class="cn">Some</span>(<span class="pp">esp_idf_sys::</span>esp_crt_bundle_attach)<span class="op">,</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">..</span><span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">?;</span></span></code></pre></div>
<h3 data-number="13.0.12" id="interacting-with-http"><span
class="header-section-number">13.0.12</span> Interacting with HTTP</h3>
<p>Once the HTTP client is configured, interacting with it involves
initiating requests, handling responses, and processing the received
data. The <code>EspHttpConnection</code> abstraction provides methods to
manage these interactions seamlessly.</p>
<h4 data-number="13.0.12.1" id="initiating-requests-responses"><span
class="header-section-number">13.0.12.1</span> Initiating Requests &amp;
Responses</h4>
<p>To initiate an HTTP request, the <code>initiate_request</code> method
of <code>EspHttpConnection</code> is used. This method requires
specifying the request type (e.g., GET, POST), the target URL, and any
headers that need to accompany the request. For example, initiating a
GET request to “https://httpbin.org/get” can be done as follows:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> url <span class="op">=</span> <span class="st">&quot;https://httpbin.org/get&quot;</span><span class="op">;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _request <span class="op">=</span> httpconnection<span class="op">.</span>initiate_request(<span class="pp">Method::</span>Get<span class="op">,</span> url<span class="op">,</span> <span class="op">&amp;</span>[])<span class="op">?;</span></span></code></pre></div>
<p>After sending the request, the <code>initiate_response</code> method
is called to handle the incoming response from the server. This
structured approach ensures that requests and responses are managed
effectively.</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>httpconnection<span class="op">.</span>initiate_response()<span class="op">?;</span></span></code></pre></div>
<h4 data-number="13.0.12.2" id="processing-http-responses"><span
class="header-section-number">13.0.12.2</span> Processing HTTP
Responses</h4>
<p>Handling the server’s response involves retrieving and interpreting
various components of the HTTP response. The
<code>EspHttpConnection</code> provides several methods for this
purpose:</p>
<ul>
<li><code>status</code>: Retrieves the HTTP status code (e.g., 200 for
success).</li>
<li><code>status_message</code>: Provides the corresponding status
message.</li>
<li><code>header</code>: Allows retrieval of specific headers from the
response.</li>
</ul>
<p>For instance, to check if the request was successful and to retrieve
a specific header:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> status_code <span class="op">=</span> httpconnection<span class="op">.</span>status()<span class="op">;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> status_msg <span class="op">=</span> httpconnection<span class="op">.</span>status_message()<span class="op">;</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(content_type) <span class="op">=</span> httpconnection<span class="op">.</span>header(<span class="st">&quot;Content-Type&quot;</span>) <span class="op">{</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Process the Content-Type header</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These methods return results that help verify the success of the
request and access any additional information provided by the server.
While comprehensive response handling, such as reading and parsing the
response body, requires additional code, these methods offer essential
tools for managing basic HTTP interactions and ensuring reliable network
communication.</p>
<h3 data-number="13.0.13" id="http-server-overview"><span
class="header-section-number">13.0.13</span> HTTP Server Overview</h3>
<p>An HTTP server is a fundamental component in web architecture,
responsible for handling client requests and serving the appropriate
resources. Unlike client-side interactions where the client initiates
communication, the server operates continuously, listening for incoming
connections and responding to requests such as fetching HTML pages or
other resources. When a client, like a web browser, requests a webpage,
the server processes the request, retrieves the necessary resources, and
sends back an HTTP response containing the requested data and a status
code indicating the result of the request (e.g., <code>200 OK</code> for
success or <code>404 Not Found</code> if the resource is unavailable).
Understanding the server-side request handling process is essential for
developing robust web applications and IoT solutions that require
reliable communication between devices and servers.</p>
<h3 data-number="13.0.14" id="configuring-an-http-server"><span
class="header-section-number">13.0.14</span> Configuring an HTTP
Server</h3>
<p>Configuring an HTTP server on ESP devices using Rust involves several
key steps to ensure that the server can handle client requests
effectively. This process leverages the <code>esp-idf-svc</code> crate,
which provides abstractions for managing HTTP server functionalities
within the ESP-IDF framework. The configuration process is methodical,
starting from initializing peripherals to defining response behaviors
for different HTTP methods and endpoints.</p>
<h4 data-number="13.0.14.1" id="take-the-peripherals-8"><span
class="header-section-number">13.0.14.1</span> Take the Peripherals</h4>
<p>The first step in setting up an HTTP server is to take control of the
device’s peripherals. This is achieved using the
<code>Peripherals::take().unwrap()</code> method, which initializes the
necessary hardware components required for networking and server
operations. Ensuring that peripherals are properly initialized is
crucial for the subsequent configuration steps and for the reliable
functioning of the HTTP server.</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<h4 data-number="13.0.14.2" id="connect-to-wifi-1"><span
class="header-section-number">13.0.14.2</span> Connect to WiFi</h4>
<p>Before the HTTP server can handle incoming requests, the device must
be connected to a WiFi network. This step is identical to the WiFi
configuration process previously outlined, where the device is set up
either as a station or an access point. Successfully connecting to WiFi
provides the server with the necessary network access to listen for and
respond to client requests.</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sysloop <span class="op">=</span> <span class="pp">EspSystemEventLoop::</span>take()<span class="op">?;</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> nvs <span class="op">=</span> <span class="pp">EspDefaultNvsPartition::</span>take()<span class="op">?;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wifi <span class="op">=</span> <span class="pp">EspWifi::</span>new(peripherals<span class="op">.</span>modem<span class="op">,</span> sysloop<span class="op">,</span> <span class="cn">Some</span>(nvs))<span class="op">?;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>set_configuration(<span class="op">&amp;</span><span class="pp">Configuration::</span>Client(ClientConfiguration <span class="op">{</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    ssid<span class="op">:</span> <span class="st">&quot;SSID&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    password<span class="op">:</span> <span class="st">&quot;PASSWORD&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    auth_method<span class="op">:</span> <span class="pp">AuthMethod::</span><span class="cn">None</span><span class="op">,</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">..</span><span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>))<span class="op">?;</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>start()<span class="op">?;</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>connect()<span class="op">?;</span></span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>wait_netif_up()<span class="op">?;</span></span></code></pre></div>
<h4 data-number="13.0.14.3"
id="create-and-configure-an-http-server-instance"><span
class="header-section-number">13.0.14.3</span> Create and Configure an
HTTP Server Instance</h4>
<p>Creating and configuring an HTTP server involves instantiating the
<code>EspHttpServer</code> abstraction from the
<code>esp_idf_svc::http::server</code> module. This is done using the
<code>new</code> method, which takes a reference to a
<code>http::server::Configuration</code> struct. The default
configuration is typically sufficient for basic server operations, but
it can be customized as needed based on specific networking or protocol
requirements.</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create Server Connection Handle</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> httpserver <span class="op">=</span> <span class="pp">EspHttpServer::</span>new(<span class="op">&amp;</span><span class="pp">Configuration::</span><span class="kw">default</span>())<span class="op">?;</span></span></code></pre></div>
<h3 data-number="13.0.15" id="interacting-with-an-http-server"><span
class="header-section-number">13.0.15</span> Interacting with an HTTP
Server</h3>
<p>Once the HTTP server is configured and running, it needs to handle
incoming requests and respond appropriately. This involves defining
response behaviors for different HTTP methods and endpoints using the
<code>fn_handler</code> method provided by the
<code>EspHttpServer</code> abstraction.</p>
<h4 data-number="13.0.15.1" id="defining-response-behavior"><span
class="header-section-number">13.0.15.1</span> Defining Response
Behavior</h4>
<p>The <code>fn_handler</code> method allows developers to register
handler functions that define how the server should respond to specific
requests. Each handler is associated with a particular URL and HTTP
method. For example, to handle GET requests to the root URL
(<code>"/"</code>), a handler can be defined as follows:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define Server RequestHandler Behavior for GET on Root URL</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>httpserver<span class="op">.</span>fn_handler(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">Method::</span>Get<span class="op">,</span> <span class="op">|</span>request<span class="op">|</span> <span class="op">{</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Retrieve HTML String</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> html <span class="op">=</span> index_html()<span class="op">;</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Respond with OK status</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> response <span class="op">=</span> request<span class="op">.</span>into_ok_response()<span class="op">?;</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return Requested Object (IndexPage)</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>    response<span class="op">.</span>write(html<span class="op">.</span>as_bytes())<span class="op">?;</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span><span class="pp">::</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="pp">anyhow::</span><span class="bu">Error</span><span class="op">&gt;</span>(())</span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>)<span class="op">?;</span></span></code></pre></div>
<p>In this example:</p>
<ol type="1">
<li>Define Handler: The handler is registered for the root URL
(<code>"/"</code>) and the GET method.</li>
<li>Retrieve Content: The <code>index_html()</code> function generates
or retrieves the HTML content to be served.</li>
<li>Create Response: The <code>into_ok_response()</code> method creates
an HTTP response with a <code>200 OK</code> status.</li>
<li>Write Content: The HTML content is written to the response
body.</li>
<li>Finalize: The handler completes successfully, allowing the server to
send the response to the client.</li>
</ol>
<h3 data-number="13.0.16" id="sntp-overview"><span
class="header-section-number">13.0.16</span> SNTP Overview</h3>
<p>SNTP, or Simple Network Time Protocol, is a protocol designed to
synchronize the clocks of devices over a network. It ensures that
devices such as computers, routers, and servers maintain accurate and
consistent time references by communicating with dedicated time servers.
Unlike its more complex counterpart, NTP (Network Time Protocol), SNTP
offers a lightweight solution suitable for most basic time
synchronization needs where high precision is not critical.</p>
<h3 data-number="13.0.17" id="how-sntp-works"><span
class="header-section-number">13.0.17</span> How SNTP Works</h3>
<p>SNTP operates through a straightforward four-step process to maintain
accurate time across devices:</p>
<ol type="1">
<li>Requesting the Time: A device, such as an ESP microcontroller, sends
a request to a network time server to obtain the current time.</li>
<li>Time Server Responds: The time server receives the request and
replies with the current time, typically precise to the
millisecond.</li>
<li>Adjusting the Clock: The device receives the time data from the
server and adjusts its internal clock to match the received time,
ensuring consistency across the network.</li>
<li>Regular Updates: To maintain accuracy, SNTP can be configured to
periodically send time synchronization requests at regular intervals,
allowing devices to correct any drift in their internal clocks.</li>
</ol>
<h3 data-number="13.0.18" id="key-features-of-sntp"><span
class="header-section-number">13.0.18</span> Key Features of SNTP</h3>
<ul>
<li>Simplicity: SNTP is a simplified version of NTP, making it easier to
implement for devices that do not require the advanced features and high
precision offered by NTP.</li>
<li>Lightweight Protocol: Operating over UDP (User Datagram Protocol),
SNTP benefits from a connectionless and low-overhead communication
method, which is ideal for sending small packets of data with minimal
delay.</li>
<li>Reliability: By relying on Coordinated Universal Time (UTC), SNTP
provides a standardized and accurate time reference that ensures all
synchronized devices operate on the same time basis.</li>
</ul>
<h3 data-number="13.0.19" id="why-use-sntp"><span
class="header-section-number">13.0.19</span> Why Use SNTP</h3>
<p>SNTP is particularly advantageous in scenarios where:</p>
<ul>
<li>Resource Constraints: Devices with limited processing power and
memory, such as microcontrollers in IoT applications, can efficiently
handle SNTP without the complexity of full NTP implementations.</li>
<li>Basic Synchronization Needs: Applications that require consistent
timekeeping without the necessity for millisecond-level precision
benefit from the simplicity and efficiency of SNTP.</li>
<li>Network Efficiency: The use of UDP allows for faster communication
with lower overhead, making SNTP suitable for networks where bandwidth
and latency are critical factors.</li>
</ul>
<p>Coordinated Universal Time (UTC) serves as the global time standard
for SNTP. By synchronizing to UTC, SNTP ensures that all devices across
different regions and networks adhere to a uniform time reference. This
uniformity is essential for applications that rely on accurate
timestamps, logging, and coordinated operations across multiple
devices.</p>
<h3 data-number="13.0.20" id="configuring-an-sntp-instance"><span
class="header-section-number">13.0.20</span> Configuring an SNTP
Instance</h3>
<p>Configuring SNTP on ESP devices using Rust involves creating and
setting up an SNTP client instance. This process leverages the
<code>esp-idf-svc</code> crate, which provides the <code>EspSntp</code>
abstraction for managing SNTP functionalities within the ESP-IDF
framework.</p>
<h4 data-number="13.0.20.1" id="take-the-peripherals-9"><span
class="header-section-number">13.0.20.1</span> Take the Peripherals</h4>
<p>The initial step involves taking control of the device’s peripherals
to ensure that all necessary hardware components are initialized and
ready for network operations.</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">Peripherals::</span>take()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<h4 data-number="13.0.20.2" id="connect-to-wifi-2"><span
class="header-section-number">13.0.20.2</span> Connect to WiFi</h4>
<p>Before the device can synchronize its time, it must be connected to a
WiFi network. This step is identical to the WiFi configuration process
outlined earlier.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sysloop <span class="op">=</span> <span class="pp">EspSystemEventLoop::</span>take()<span class="op">?;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> nvs <span class="op">=</span> <span class="pp">EspDefaultNvsPartition::</span>take()<span class="op">?;</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wifi <span class="op">=</span> <span class="pp">EspWifi::</span>new(peripherals<span class="op">.</span>modem<span class="op">,</span> sysloop<span class="op">,</span> <span class="cn">Some</span>(nvs))<span class="op">?;</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>set_configuration(<span class="op">&amp;</span><span class="pp">Configuration::</span>Client(ClientConfiguration <span class="op">{</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    ssid<span class="op">:</span> <span class="st">&quot;SSID&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    password<span class="op">:</span> <span class="st">&quot;PASSWORD&quot;</span><span class="op">.</span>try_into()<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>    auth_method<span class="op">:</span> <span class="pp">AuthMethod::</span><span class="cn">None</span><span class="op">,</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">..</span><span class="bu">Default</span><span class="pp">::</span><span class="kw">default</span>()</span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>))<span class="op">?;</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>start()<span class="op">?;</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>connect()<span class="op">?;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>wifi<span class="op">.</span>wait_netif_up()<span class="op">?;</span></span></code></pre></div>
<h4 data-number="13.0.20.3"
id="create-and-configure-an-sntp-instance"><span
class="header-section-number">13.0.20.3</span> Create and Configure an
SNTP Instance</h4>
<p>Instantiating and configuring SNTP is straightforward, especially
with the default configuration. The <code>EspSntp::new_default()</code>
method initializes an SNTP client with default settings. Custom
configurations are also possible, allowing the selection of different
SNTP servers, operating modes, or synchronization modes as needed.</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ntp <span class="op">=</span> <span class="pp">EspSntp::</span>new_default()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb117"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ntp <span class="op">=</span> <span class="pp">EspSntp::</span>new_default()<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<h3 data-number="13.0.21" id="interacting-with-sntp"><span
class="header-section-number">13.0.21</span> Interacting with SNTP</h3>
<p>Once the SNTP instance is created and configured, the device can
interact with it to manage time synchronization.</p>
<h4 data-number="13.0.21.1" id="synchronizing-time"><span
class="header-section-number">13.0.21.1</span> Synchronizing Time</h4>
<p>The <code>EspSntp</code> abstraction provides the
<code>get_sync_status</code> method to check the synchronization status
with the NTP server. This method returns a <code>SyncStatus</code> enum,
indicating whether the synchronization process is completed or still in
progress.</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> SyncStatus <span class="op">{</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    Reset<span class="op">,</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Other variants...</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To ensure that the system time has been synchronized, the following
loop can be used:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ntp<span class="op">.</span>get_sync_status() <span class="op">!=</span> <span class="pp">SyncStatus::</span>Completed <span class="op">{</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait or perform other tasks</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb120"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> ntp<span class="op">.</span>get_sync_status() <span class="op">!=</span> <span class="pp">SyncStatus::</span>Completed <span class="op">{</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Wait or perform other tasks</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Once synchronization is completed, the device’s system time can be
retrieved using Rust’s standard library:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::time::</span>SystemTime<span class="op">;</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> current_time <span class="op">=</span> <span class="pp">SystemTime::</span>now()<span class="op">;</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Synchronized System Time: {:?}&quot;</span><span class="op">,</span> current_time)<span class="op">;</span></span></code></pre></div>
<h1 data-number="14" id="the-embassy-framework-no-std"><span
class="header-section-number">14</span> The Embassy Framework
(no-std)</h1>
<p>In a blocking approach, the processor sits idle, busy waiting
(continuously polling) for a result. This not only wastes processing
power but also prevents other code from executing concurrently. A
potential solution to this issue is using interrupts, which can notify
the application when an event occurs. However, configuring interrupts
can be daunting and increases code verbosity.</p>
<h4 data-number="14.0.0.1"
id="introducing-asynchronous-programming"><span
class="header-section-number">14.0.0.1</span> Introducing Asynchronous
Programming</h4>
<p>Asynchronous programming offers an elegant alternative and has gained
significant popularity in Rust circles. Asynchronous (often abbreviated
as “async”) programming in Rust allows you to run multiple tasks
concurrently while preserving the synchronous, readable nature of
regular Rust code. Async programming in Rust involves three main
components:</p>
<ol type="1">
<li>Futures: Represent work that may complete in the future.</li>
<li>Async/Await Syntax: Handles asynchronous tasks in a non-blocking
manner.</li>
<li>Runtime: Executes the asynchronous tasks.</li>
</ol>
<p>Rust’s asynchronous operation is based on futures, which are polled
in the background until they signal completion. The <code>async</code>
keyword transforms a block of code into a future, and the
<code>await</code> keyword is used to wait for the future to resolve
without blocking the entire thread. The <code>await</code> keyword also
implies deferred execution, allowing the program to handle other tasks
while waiting for the future to complete.</p>
<p>Unlike some other languages, Rust does not include a built-in runtime
for asynchronous operations. Instead, developers must choose a runtime,
such as Tokio, async-std, smol, etc., and include it as a dependency. In
embedded Rust development, the Embassy executor serves this purpose.</p>
<h4 data-number="14.0.0.2" id="the-embassy-executor"><span
class="header-section-number">14.0.0.2</span> The Embassy Executor</h4>
<p>The Embassy executor is part of the Embassy framework, which offers
more than just a runtime. Embassy provides an efficient and easy-to-use
multitasking environment using Rust’s <code>async/await</code> syntax.
Additionally, Embassy offers Hardware Abstraction Layers (HALs) for
select hardware, providing safe, idiomatic Rust APIs for hardware
capabilities. It also includes crates for time management, connectivity,
and networking features, among others. Embassy is poised to become a
significant tool in embedded development by offering a lightweight
runtime that facilitates writing multithreaded, efficient, and safe code
without the overhead of a Real-Time Operating System (RTOS).</p>
<p>Notable Embassy Crates:</p>
<ul>
<li>embassy-time: Provides timekeeping, delays, and timeout
abstractions.</li>
<li>embassy-net: Offers an async network stack.</li>
<li>embassy-sync: Supplies synchronization primitives and data
structures with async support.</li>
<li>embassy-usb: Delivers an async USB device stack.</li>
<li>embassy-executor: Contains async/await executor abstractions.</li>
</ul>
<p>Asynchronous programming is powerful and has been prevalent in areas
like web development. In embedded development, it is relatively new and
may take some time for wide-scale adoption. However, Embassy’s stable
and efficient abstractions make it a promising candidate for the future
of embedded Rust development.</p>
<h4 data-number="14.0.0.3" id="getting-started-with-embassy"><span
class="header-section-number">14.0.0.3</span> Getting Started with
Embassy</h4>
<p>Getting started with the Embassy framework is straightforward.
Technically, you need to:</p>
<ol type="1">
<li>Import the Embassy crates.</li>
<li>Initialize the background executor.</li>
<li>Use async abstractions.</li>
</ol>
<p>Condition: The underlying HAL used with Embassy must support async
development. This means the HAL should implement or provide access to
async functions. ESP devices support the Embassy framework by leveraging
community-driven HALs, such as <code>embedded-hal-async</code> and
<code>embedded-io-async</code>, maintained by the embedded Rust
workgroup. These HALs establish common behavior among devices, enabling
portability across a wider range of hardware platforms.</p>
<p>Note: Currently, no-std Embassy support with ESPs is limited to
peripherals supported by the <code>embedded-hal-async</code> and
<code>embedded-io-async</code> crates. Not all peripherals have async
abstractions, so consult the documentation for supported
peripherals.</p>
<p>Below is a basic template demonstrating the use of Embassy with the
<code>esp-hal</code>. This template includes two tasks: the main task
and an <code>embassy_task</code> spawned by main. Key differences from
earlier templates include:</p>
<ol type="1">
<li><code>main</code> Function Declared as <code>async</code>: Allows
deferring execution to the background executor and awaiting
futures.</li>
<li>Spawner Handle: Passed to <code>main</code> to spawn additional
tasks.</li>
<li>Initialization of the Embassy Executor: Using
<code>embassy::init</code> with an async timer instance.</li>
<li>Spawning Tasks: Using <code>spawner.spawn</code> to add tasks to the
executor.</li>
<li>Delay Creation with <code>Timer::after</code>: Creates a future that
resolves after a specified duration.</li>
</ol>
<div class="sourceCode" id="cb122"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_hal_embassy<span class="op">;</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> embassy_task() <span class="op">{</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Task Loop Code</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Print from an embassy task&quot;</span>)<span class="op">;</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1_000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Init!&quot;</span>)<span class="op">;</span></span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb122-28"><a href="#cb122-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-29"><a href="#cb122-29" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(embassy_task())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb122-30"><a href="#cb122-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-31"><a href="#cb122-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb122-32"><a href="#cb122-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Main loop code</span></span>
<span id="cb122-33"><a href="#cb122-33" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Print from the main task&quot;</span>)<span class="op">;</span></span>
<span id="cb122-34"><a href="#cb122-34" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">5_000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb122-35"><a href="#cb122-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb122-36"><a href="#cb122-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb123"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[dependencies]</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="dt">esp-backtrace</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.14.1&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;esp32c3&quot;</span><span class="op">,</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;exception-handler&quot;</span><span class="op">,</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;panic-handler&quot;</span><span class="op">,</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;println&quot;</span><span class="op">,</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a><span class="op">] }</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a><span class="dt">esp-hal</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.21.0&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;esp32c3&quot;</span><span class="op">] }</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="dt">esp-println</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.12.0&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;esp32c3&quot;</span><span class="op">,</span> <span class="st">&quot;log&quot;</span><span class="op">] }</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a><span class="dt">log</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.4.20&quot;</span><span class="op"> }</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a><span class="dt">esp-hal-embassy</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.4.0&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;esp32c3&quot;</span><span class="op">,</span></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;integrated-timers&quot;</span><span class="op">,</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;log&quot;</span><span class="op">,</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a><span class="op">] }</span></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a><span class="dt">embassy-executor</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;0.6.0&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;task-arena-size-40960&quot;</span><span class="op">] }</span></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a><span class="dt">embassy-futures</span> <span class="op">=</span> <span class="st">&quot;0.1.1&quot;</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a><span class="dt">embassy-sync</span> <span class="op">=</span> <span class="st">&quot;0.6.0&quot;</span></span>
<span id="cb123-19"><a href="#cb123-19" aria-hidden="true" tabindex="-1"></a><span class="dt">embassy-time</span> <span class="op">=</span> <span class="st">&quot;0.3.2&quot;</span></span>
<span id="cb123-20"><a href="#cb123-20" aria-hidden="true" tabindex="-1"></a><span class="dt">embedded-hal-async</span> <span class="op">=</span> <span class="st">&quot;1.0.0&quot;</span></span>
<span id="cb123-21"><a href="#cb123-21" aria-hidden="true" tabindex="-1"></a><span class="dt">embedded-io-async</span> <span class="op">=</span> <span class="st">&quot;0.6.1&quot;</span></span></code></pre></div>
<p>Explanation of <code>Cargo.toml</code> Dependencies:</p>
<ul>
<li>esp-backtrace: Handles backtraces for debugging.</li>
<li>esp-hal: Provides Hardware Abstraction Layer for ESP devices.</li>
<li>esp-println: Facilitates printing/logging capabilities.</li>
<li>log: Logging facade.</li>
<li>esp-hal-embassy: Integrates Embassy with the ESP HAL.</li>
<li>embassy-executor: Async executor for Embassy.</li>
<li>embassy-futures: Future abstractions for Embassy.</li>
<li>embassy-sync: Synchronization primitives for async tasks.</li>
<li>embassy-time: Time management utilities for Embassy.</li>
<li>embedded-hal-async: Async traits for embedded HAL.</li>
<li>embedded-io-async: Async traits for embedded IO.</li>
</ul>
<h4 data-number="14.0.0.4" id="synchronization-primitives"><span
class="header-section-number">14.0.0.4</span> Synchronization
Primitives</h4>
<p>In the following sections, we will explore some of Embassy’s
synchronization primitives that are particularly useful when sharing
data among tasks or threads. These primitives help manage access to
shared resources without introducing race conditions, ensuring
thread-safe operations in an asynchronous environment.</p>
<h3 data-number="14.0.1" id="synchronization-primitives-1"><span
class="header-section-number">14.0.1</span> Synchronization
Primitives</h3>
<p>When introducing interrupts earlier, dealing with global variables
presented significant challenges. The primary issue stems from ensuring
that variables are shared safely among threads to prevent
synchronization problems like data races. However, using the Embassy
framework, this experience is greatly improved through several
synchronization primitives provided by the <code>embassy-sync</code>
crate.</p>
<p>But with several primitives available, how do we decide which one to
use? The answer lies in how you plan to share the data. Specifically,
consider whether you want to:</p>
<ol type="1">
<li>Share data among tasks in a blocking manner</li>
<li>Require async support for shared data</li>
<li>Need the primitive to notify a task when the data it holds
changes</li>
</ol>
<p>The <code>embassy-sync</code> crate offers the following primitives
to cater to these scenarios:</p>
<ul>
<li>Channel: A Multiple Producer Multiple Consumer (MPMC) channel where
each message sent is received by a single consumer.</li>
<li>PubSubChannel: A broadcast (publish-subscribe) channel where each
message sent is received by all consumers.</li>
<li>Signal: Signals the latest value to a single consumer.</li>
<li>Mutex: Synchronizes state between asynchronous tasks.</li>
<li>Pipe: A byte stream that implements <code>embedded-io</code>
traits.</li>
</ul>
<p>Additionally, there are Waker primitives, which are utilities to
signal the executor to poll a Future. These include:</p>
<ul>
<li>WakerRegistration: Utility to register and wake a Waker.</li>
<li>AtomicWaker: A variant of <code>WakerRegistration</code> accessible
using a non-mut API.</li>
<li>MultiWakerRegistration: Utility for registering and waking multiple
Wakers.</li>
</ul>
<h4 data-number="14.0.1.1" id="use-cases"><span
class="header-section-number">14.0.1.1</span> Use Cases</h4>
<p>The use of different synchronization primitives can be categorized
into three main cases:</p>
<ol type="1">
<li>Reading/Writing from/to Multiple Tasks: Sharing simple data among
multiple tasks.</li>
<li>Reading/Writing Across Async Tasks: Sharing data across asynchronous
tasks, requiring safe mutation while awaiting.</li>
<li>Wait for Value Change: Scenarios where a receiving task waits for a
change in a value.</li>
</ol>
<p>In the following sections, we will explore the constructs available
under each category.</p>
<hr />
<h4 data-number="14.0.1.2" id="the-atomicu32-type"><span
class="header-section-number">14.0.1.2</span> The <code>AtomicU32</code>
Type</h4>
<p>While <code>AtomicU32</code> is not explicitly listed among the
Embassy synchronization primitives, it is a valuable tool available in
Rust’s <code>core::sync::atomic</code> module. It is especially handy
when you need to share a simple value among tasks without the overhead
of more complex synchronization mechanisms. However,
<code>AtomicU32</code> works only for types that are <code>u32</code> or
smaller in size. For larger types, you should use a global blocking
<code>Mutex</code>.</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">core::sync::atomic::</span><span class="op">{</span>AtomicU32<span class="op">,</span> Ordering<span class="op">};</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Shared AtomicU32 variable initialized to 0</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> AtomicU32 <span class="op">=</span> <span class="pp">AtomicU32::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task() <span class="op">{</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Load the current value, increment, and store it back</span></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shared_var <span class="op">=</span> SHARED<span class="op">.</span>load(<span class="pp">Ordering::</span>Relaxed)<span class="op">;</span></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>        SHARED<span class="op">.</span>store(shared_var<span class="op">.</span>wrapping_add(<span class="dv">1</span>)<span class="op">,</span> <span class="pp">Ordering::</span>Relaxed)<span class="op">;</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn the asynchronous task</span></span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-38"><a href="#cb124-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb124-39"><a href="#cb124-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Load the current shared value</span></span>
<span id="cb124-40"><a href="#cb124-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shared <span class="op">=</span> SHARED<span class="op">.</span>load(<span class="pp">Ordering::</span>Relaxed)<span class="op">;</span></span>
<span id="cb124-41"><a href="#cb124-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb124-42"><a href="#cb124-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb124-43"><a href="#cb124-43" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb124-44"><a href="#cb124-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb124-45"><a href="#cb124-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the shared value</span></span>
<span id="cb124-46"><a href="#cb124-46" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> shared)<span class="op">;</span></span>
<span id="cb124-47"><a href="#cb124-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-48"><a href="#cb124-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup: A global <code>SHARED</code> variable of type
<code>AtomicU32</code> is defined and initialized to
<code>0</code>.</li>
<li>Asynchronous Task (<code>async_task</code>):
<ul>
<li>Continuously increments the <code>SHARED</code> variable every
second.</li>
<li>Uses <code>load</code> with <code>Ordering::Relaxed</code> to
retrieve the current value.</li>
<li>Uses <code>store</code> with <code>Ordering::Relaxed</code> to
update the value.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns the <code>async_task</code>.</li>
<li>In the main loop, it reads and prints the <code>SHARED</code> value
every second.</li>
</ul></li>
</ol>
<p><em>Note: <code>Ordering::Relaxed</code> is used here for simplicity,
assuming that the exact ordering of operations is not critical. For more
complex synchronization requirements, stronger memory ordering
guarantees may be necessary.</em></p>
<hr />
<h4 data-number="14.0.1.3" id="the-blocking-mutex-type"><span
class="header-section-number">14.0.1.3</span> The Blocking
<code>Mutex</code> Type</h4>
<p>For scenarios where you need to share data types larger than
<code>u32</code> or require more complex synchronization, a blocking
<code>Mutex</code> is the appropriate choice. The blocking
<code>Mutex</code> ensures safe access to shared data by allowing only
one task to access the data at a time, effectively preventing data
races.</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">core::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::blocking_mutex::raw::</span>CriticalSectionRawMutex<span class="op">;</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::blocking_mutex::</span>Mutex<span class="op">;</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Shared Mutex-protected u32 variable initialized to 0</span></span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> Mutex<span class="op">&lt;</span>CriticalSectionRawMutex<span class="op">,</span> RefCell<span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="pp">RefCell::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task() <span class="op">{</span></span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Acquire the mutex lock and modify the shared value</span></span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>        SHARED<span class="op">.</span>lock(<span class="op">|</span>f<span class="op">|</span> <span class="op">{</span></span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> val <span class="op">=</span> f<span class="op">.</span>borrow_mut()<span class="op">.</span>wrapping_add(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a>            f<span class="op">.</span>replace(val)<span class="op">;</span></span>
<span id="cb125-23"><a href="#cb125-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb125-24"><a href="#cb125-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb125-25"><a href="#cb125-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb125-26"><a href="#cb125-26" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb125-27"><a href="#cb125-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-28"><a href="#cb125-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb125-29"><a href="#cb125-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-30"><a href="#cb125-30" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb125-31"><a href="#cb125-31" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb125-32"><a href="#cb125-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb125-33"><a href="#cb125-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb125-34"><a href="#cb125-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb125-35"><a href="#cb125-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb125-36"><a href="#cb125-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb125-37"><a href="#cb125-37" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb125-38"><a href="#cb125-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb125-39"><a href="#cb125-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn the asynchronous task</span></span>
<span id="cb125-40"><a href="#cb125-40" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb125-41"><a href="#cb125-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-42"><a href="#cb125-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb125-43"><a href="#cb125-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb125-44"><a href="#cb125-44" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb125-45"><a href="#cb125-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb125-46"><a href="#cb125-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Acquire the mutex lock and read the shared value</span></span>
<span id="cb125-47"><a href="#cb125-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shared <span class="op">=</span> SHARED<span class="op">.</span>lock(<span class="op">|</span>f<span class="op">|</span> f<span class="op">.</span>borrow()<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb125-48"><a href="#cb125-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb125-49"><a href="#cb125-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the shared value</span></span>
<span id="cb125-50"><a href="#cb125-50" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> shared)<span class="op">;</span></span>
<span id="cb125-51"><a href="#cb125-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb125-52"><a href="#cb125-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup: A global <code>SHARED</code> variable is
defined as a <code>Mutex</code> protecting a
<code>RefCell&lt;u32&gt;</code>, initialized to <code>0</code>.</li>
<li>Asynchronous Task (<code>async_task</code>):
<ul>
<li>Continuously increments the <code>SHARED</code> variable every
second.</li>
<li>Uses the <code>lock</code> method to safely access and modify the
shared data.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns the <code>async_task</code>.</li>
<li>In the main loop, it acquires the mutex lock to read the
<code>SHARED</code> value every second and prints it.</li>
</ul></li>
</ol>
<p>Key Differences from <code>AtomicU32</code>:</p>
<ul>
<li>Data Type Flexibility: The <code>Mutex</code> allows for sharing
data types larger than <code>u32</code>, providing greater
flexibility.</li>
<li>Locking Mechanism: The <code>Mutex</code> ensures that only one task
can access the shared data at a time, preventing concurrent
modifications and ensuring data integrity.</li>
<li>No Atomic Operations: Unlike <code>AtomicU32</code>, which provides
atomic operations, the <code>Mutex</code> relies on locking to
synchronize access.</li>
</ul>
<p><em>Note: The <code>CriticalSectionRawMutex</code> is chosen for this
example, but depending on the context and requirements, other mutex
types provided by Embassy may be more appropriate.</em></p>
<h4 data-number="14.0.1.4" id="the-async-mutex-type"><span
class="header-section-number">14.0.1.4</span> The
<code>async Mutex</code> Type</h4>
<p>While the blocking <code>Mutex</code> ensures safe access to shared
data by allowing only one task to hold the lock at a time, it does not
hold the lock across <code>await</code> points. In contrast, the
<code>async Mutex</code> provided by the <code>embassy-sync</code> crate
allows a task to <code>await</code> while holding the lock, enabling
other tasks to proceed without being blocked indefinitely.</p>
<p>Key Differences: - Blocking <code>Mutex</code>: - Does not support
holding the lock across <code>await</code> points. - Suitable for
scenarios where tasks do not need to hold the lock while awaiting. -
<code>async Mutex</code>: - Allows holding the lock across
<code>await</code> points. - Suitable for scenarios where tasks need to
hold the lock while performing asynchronous operations.</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::mutex::</span>Mutex<span class="op">;</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_hal_embassy<span class="op">;</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb126-11"><a href="#cb126-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-12"><a href="#cb126-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Shared async Mutex-protected u32 variable initialized to 0</span></span>
<span id="cb126-13"><a href="#cb126-13" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> Mutex<span class="op">&lt;</span><span class="pp">embassy_sync::mutex::raw::</span>CriticalSectionRawMutex<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;</span> </span>
<span id="cb126-14"><a href="#cb126-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb126-15"><a href="#cb126-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-16"><a href="#cb126-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb126-17"><a href="#cb126-17" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task() <span class="op">{</span></span>
<span id="cb126-18"><a href="#cb126-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb126-19"><a href="#cb126-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb126-20"><a href="#cb126-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Acquire the mutex lock and modify the shared value</span></span>
<span id="cb126-21"><a href="#cb126-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> shared <span class="op">=</span> SHARED<span class="op">.</span>lock()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb126-22"><a href="#cb126-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>shared <span class="op">=</span> shared<span class="op">.</span>wrapping_add(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb126-23"><a href="#cb126-23" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb126-24"><a href="#cb126-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Hold the lock while awaiting (simulated by a delay)</span></span>
<span id="cb126-25"><a href="#cb126-25" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb126-26"><a href="#cb126-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb126-27"><a href="#cb126-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The lock is automatically released here</span></span>
<span id="cb126-28"><a href="#cb126-28" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb126-29"><a href="#cb126-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb126-30"><a href="#cb126-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb126-31"><a href="#cb126-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-32"><a href="#cb126-32" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb126-33"><a href="#cb126-33" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb126-34"><a href="#cb126-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb126-35"><a href="#cb126-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb126-36"><a href="#cb126-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-37"><a href="#cb126-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb126-38"><a href="#cb126-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb126-39"><a href="#cb126-39" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb126-40"><a href="#cb126-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-41"><a href="#cb126-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn the asynchronous task</span></span>
<span id="cb126-42"><a href="#cb126-42" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb126-43"><a href="#cb126-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-44"><a href="#cb126-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb126-45"><a href="#cb126-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb126-46"><a href="#cb126-46" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb126-47"><a href="#cb126-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb126-48"><a href="#cb126-48" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Acquire the mutex lock and read the shared value</span></span>
<span id="cb126-49"><a href="#cb126-49" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shared <span class="op">=</span> SHARED<span class="op">.</span>lock()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb126-50"><a href="#cb126-50" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb126-51"><a href="#cb126-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the shared value</span></span>
<span id="cb126-52"><a href="#cb126-52" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> shared)<span class="op">;</span></span>
<span id="cb126-53"><a href="#cb126-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb126-54"><a href="#cb126-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup:
<ul>
<li>A global <code>SHARED</code> variable is defined as an
<code>async Mutex</code> protecting a <code>u32</code>, initialized to
<code>0</code>.</li>
</ul></li>
<li>Asynchronous Task (<code>async_task</code>):
<ul>
<li>Continuously increments the <code>SHARED</code> variable every
second.</li>
<li>Uses the <code>lock().await</code> method to safely acquire and hold
the mutex lock.</li>
<li>The lock is held while awaiting the timer, ensuring that no other
task can access <code>SHARED</code> during this period.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns the <code>async_task</code>.</li>
<li>In the main loop, it waits for one second, acquires the mutex lock
to read the <code>SHARED</code> value, and prints it.</li>
</ul></li>
</ol>
<p>Behavior: - The <code>async_task</code> increments the shared value
every second while holding the lock during the delay. - The main task
attempts to read the shared value every second. If the
<code>async_task</code> is holding the lock (during its
<code>await</code>), the main task will wait until the lock becomes
available. - This ensures synchronized access to the shared variable
without data races.</p>
<p>Important Considerations: - Lock Scope: The lock is held within a
scoped block <code>{ ... }</code>, ensuring it is released before the
main task attempts to acquire it again. - Ordering: Unlike atomic types,
mutexes ensure exclusive access, making them suitable for more complex
data manipulation.</p>
<hr />
<h4 data-number="14.0.1.5" id="the-signal-type"><span
class="header-section-number">14.0.1.5</span> The <code>Signal</code>
Type</h4>
<p>The <code>Signal</code> primitive is ideal for scenarios where a task
needs to be notified when a particular value changes. It provides a
simple mechanism to buffer or send a new value to another task,
effectively signaling that an update has occurred.</p>
<p>Use Case: - When one task needs to notify another task about a
specific event or data change without continuous polling.</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::signal::</span>Signal<span class="op">;</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_hal_embassy<span class="op">;</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Shared Signal-protected u32 variable</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> Signal<span class="op">&lt;</span><span class="pp">embassy_sync::mutex::raw::</span>CriticalSectionRawMutex<span class="op">,</span> <span class="dt">u32</span><span class="op">&gt;</span> </span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">=</span> <span class="pp">Signal::</span>new()<span class="op">;</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task() <span class="op">{</span></span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Signal the value 5</span></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>        SHARED<span class="op">.</span>signal(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb127-22"><a href="#cb127-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb127-23"><a href="#cb127-23" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb127-24"><a href="#cb127-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-25"><a href="#cb127-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb127-26"><a href="#cb127-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-27"><a href="#cb127-27" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb127-28"><a href="#cb127-28" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb127-29"><a href="#cb127-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb127-30"><a href="#cb127-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb127-31"><a href="#cb127-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-32"><a href="#cb127-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb127-33"><a href="#cb127-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb127-34"><a href="#cb127-34" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb127-35"><a href="#cb127-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-36"><a href="#cb127-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn the asynchronous task</span></span>
<span id="cb127-37"><a href="#cb127-37" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb127-38"><a href="#cb127-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-39"><a href="#cb127-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb127-40"><a href="#cb127-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for a signal and retrieve the value</span></span>
<span id="cb127-41"><a href="#cb127-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> val <span class="op">=</span> SHARED<span class="op">.</span>wait()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb127-42"><a href="#cb127-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb127-43"><a href="#cb127-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the received value</span></span>
<span id="cb127-44"><a href="#cb127-44" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> val)<span class="op">;</span></span>
<span id="cb127-45"><a href="#cb127-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-46"><a href="#cb127-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup:
<ul>
<li>A global <code>SHARED</code> variable is defined as a
<code>Signal</code> protecting a <code>u32</code>.</li>
</ul></li>
<li>Asynchronous Task (<code>async_task</code>):
<ul>
<li>Continuously sends (signals) the value <code>5</code> every second
using the <code>signal</code> method.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns the <code>async_task</code>.</li>
<li>In the main loop, it awaits a signal using the
<code>wait().await</code> method and prints the received value.</li>
</ul></li>
</ol>
<p>Behavior: - The <code>async_task</code> sends a signal with the value
<code>5</code> every second. - The main task waits for the signal and,
upon receiving it, prints the value. - This setup eliminates the need
for the main task to continuously poll for updates, making the
communication more efficient.</p>
<p>Advantages Over <code>AtomicU32</code>: - Event-Driven:
<code>Signal</code> allows tasks to react to specific events or changes
rather than continuously checking for updates. - Buffering: Signals can
buffer values, ensuring that important updates are not missed even if
the receiving task is busy.</p>
<hr />
<h4 data-number="14.0.1.6" id="the-channel-type"><span
class="header-section-number">14.0.1.6</span> The <code>Channel</code>
Type</h4>
<p>The <code>Channel</code> primitive expands upon the capabilities of
<code>Signal</code> by allowing multiple values to be buffered in a
queue. It supports multiple producers and multiple consumers, making it
suitable for scenarios where multiple tasks need to send and receive
messages concurrently.</p>
<p>Use Case: - When you need to buffer multiple values sent by producers
and have them processed by consumers in a first-come, first-served
manner.</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::channel::</span>Channel<span class="op">;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_hal_embassy<span class="op">;</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare a channel with capacity of 2 u32s</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> Channel<span class="op">&lt;</span><span class="pp">embassy_sync::mutex::raw::</span>CriticalSectionRawMutex<span class="op">,</span> <span class="dt">u32</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> </span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">=</span> <span class="pp">Channel::</span>new()<span class="op">;</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task_one() <span class="op">{</span></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Send the value 1</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>        SHARED<span class="op">.</span>send(<span class="dv">1</span>)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 0.5 seconds</span></span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">500</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-26"><a href="#cb128-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-27"><a href="#cb128-27" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb128-28"><a href="#cb128-28" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task_two() <span class="op">{</span></span>
<span id="cb128-29"><a href="#cb128-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb128-30"><a href="#cb128-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Send the value 2</span></span>
<span id="cb128-31"><a href="#cb128-31" aria-hidden="true" tabindex="-1"></a>        SHARED<span class="op">.</span>send(<span class="dv">2</span>)<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb128-32"><a href="#cb128-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb128-33"><a href="#cb128-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb128-34"><a href="#cb128-34" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb128-35"><a href="#cb128-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb128-36"><a href="#cb128-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb128-37"><a href="#cb128-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-38"><a href="#cb128-38" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb128-39"><a href="#cb128-39" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb128-40"><a href="#cb128-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb128-41"><a href="#cb128-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb128-42"><a href="#cb128-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-43"><a href="#cb128-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb128-44"><a href="#cb128-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb128-45"><a href="#cb128-45" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb128-46"><a href="#cb128-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-47"><a href="#cb128-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn asynchronous tasks</span></span>
<span id="cb128-48"><a href="#cb128-48" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task_one())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb128-49"><a href="#cb128-49" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task_two())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb128-50"><a href="#cb128-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-51"><a href="#cb128-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb128-52"><a href="#cb128-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Receive a value from the channel</span></span>
<span id="cb128-53"><a href="#cb128-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> val <span class="op">=</span> SHARED<span class="op">.</span>receive()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb128-54"><a href="#cb128-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb128-55"><a href="#cb128-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the received value</span></span>
<span id="cb128-56"><a href="#cb128-56" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> val)<span class="op">;</span></span>
<span id="cb128-57"><a href="#cb128-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb128-58"><a href="#cb128-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup:
<ul>
<li>A global <code>SHARED</code> channel is defined with a capacity of
<code>2</code> for <code>u32</code> values.</li>
</ul></li>
<li>Asynchronous Tasks (<code>async_task_one</code> and
<code>async_task_two</code>):
<ul>
<li><code>async_task_one</code> sends the value <code>1</code> every 0.5
seconds.</li>
<li><code>async_task_two</code> sends the value <code>2</code> every 1
second.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns both asynchronous tasks.</li>
<li>In the main loop, it awaits messages from the <code>SHARED</code>
channel and prints them as they are received.</li>
</ul></li>
</ol>
<p>Behavior: - The channel buffers up to two messages. -
<code>async_task_one</code> sends <code>1</code> every 0.5 seconds, and
<code>async_task_two</code> sends <code>2</code> every 1 second. - The
main task receives and prints each value in the order they are sent. -
If the channel is full, producers will wait (<code>await</code>) until
there is space available.</p>
<p>Important Notes: - Capacity: The channel’s capacity determines how
many messages can be buffered before producers are blocked. - Multiple
Producers: Both <code>async_task_one</code> and
<code>async_task_two</code> act as producers, sending messages to the
channel. - Single Consumer: The main task acts as the sole consumer,
receiving and processing messages.</p>
<hr />
<h4 data-number="14.0.1.7" id="the-pubsubchannel-type"><span
class="header-section-number">14.0.1.7</span> The
<code>PubSubChannel</code> Type</h4>
<p>The <code>PubSubChannel</code> is an extension of the
<code>Channel</code> type that supports a publish-subscribe (pub-sub)
communication model. Unlike <code>Channel</code>, where each message is
consumed by a single consumer, <code>PubSubChannel</code> allows
multiple subscribers to receive each published message.</p>
<p>Use Case: - When you need to broadcast messages to multiple
consumers, ensuring that each subscriber receives every message.</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>no_main<span class="at">]</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_executor::</span>Spawner<span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_sync::pubsub::</span>PubSubChannel<span class="op">;</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">embassy_time::</span><span class="op">{</span>Duration<span class="op">,</span> Timer<span class="op">};</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_backtrace <span class="kw">as</span> _<span class="op">;</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_hal::</span><span class="op">{</span><span class="pp">prelude::</span><span class="op">*,</span> <span class="pp">timer::timg::</span>TimerGroup<span class="op">};</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> esp_hal_embassy<span class="op">;</span></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">esp_println::</span>println<span class="op">;</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare a PubSub channel with capacity of 2 messages,</span></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a><span class="co">// 2 publishers, and 2 subscribers</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> SHARED<span class="op">:</span> PubSubChannel<span class="op">&lt;</span></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">embassy_sync::mutex::raw::</span>CriticalSectionRawMutex<span class="op">,</span></span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span><span class="op">,</span> <span class="co">// Capacity</span></span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span><span class="op">,</span> <span class="co">// Number of publishers</span></span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span><span class="op">,</span> <span class="co">// Number of subscribers</span></span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">PubSubChannel::</span>new()<span class="op">;</span></span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task_one() <span class="op">{</span></span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Obtain a publisher</span></span>
<span id="cb129-25"><a href="#cb129-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pub1 <span class="op">=</span> SHARED<span class="op">.</span>publisher()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb129-26"><a href="#cb129-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb129-27"><a href="#cb129-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Publish the value 1 immediately</span></span>
<span id="cb129-28"><a href="#cb129-28" aria-hidden="true" tabindex="-1"></a>        pub1<span class="op">.</span>publish_immediate(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb129-29"><a href="#cb129-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb129-30"><a href="#cb129-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 0.5 seconds</span></span>
<span id="cb129-31"><a href="#cb129-31" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">500</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb129-32"><a href="#cb129-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb129-33"><a href="#cb129-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb129-34"><a href="#cb129-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-35"><a href="#cb129-35" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">embassy_executor::</span>task<span class="at">]</span></span>
<span id="cb129-36"><a href="#cb129-36" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> async_task_two() <span class="op">{</span></span>
<span id="cb129-37"><a href="#cb129-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Obtain a publisher</span></span>
<span id="cb129-38"><a href="#cb129-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pub2 <span class="op">=</span> SHARED<span class="op">.</span>publisher()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb129-39"><a href="#cb129-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb129-40"><a href="#cb129-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Publish the value 2 immediately</span></span>
<span id="cb129-41"><a href="#cb129-41" aria-hidden="true" tabindex="-1"></a>        pub2<span class="op">.</span>publish_immediate(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb129-42"><a href="#cb129-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb129-43"><a href="#cb129-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for 1 second</span></span>
<span id="cb129-44"><a href="#cb129-44" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Timer::</span>after(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb129-45"><a href="#cb129-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb129-46"><a href="#cb129-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb129-47"><a href="#cb129-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-48"><a href="#cb129-48" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>main<span class="at">]</span></span>
<span id="cb129-49"><a href="#cb129-49" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main(spawner<span class="op">:</span> Spawner) <span class="op">{</span></span>
<span id="cb129-50"><a href="#cb129-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize and create handle for device peripherals</span></span>
<span id="cb129-51"><a href="#cb129-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> peripherals <span class="op">=</span> <span class="pp">esp_hal::</span>init(<span class="pp">esp_hal::Config::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb129-52"><a href="#cb129-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-53"><a href="#cb129-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize Embassy executor</span></span>
<span id="cb129-54"><a href="#cb129-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> timg0 <span class="op">=</span> <span class="pp">TimerGroup::</span>new(peripherals<span class="op">.</span>TIMG0)<span class="op">;</span></span>
<span id="cb129-55"><a href="#cb129-55" aria-hidden="true" tabindex="-1"></a>    <span class="pp">esp_hal_embassy::</span>init(timg0<span class="op">.</span>timer0)<span class="op">;</span></span>
<span id="cb129-56"><a href="#cb129-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-57"><a href="#cb129-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Spawn asynchronous tasks</span></span>
<span id="cb129-58"><a href="#cb129-58" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task_one())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb129-59"><a href="#cb129-59" aria-hidden="true" tabindex="-1"></a>    spawner<span class="op">.</span>spawn(async_task_two())<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb129-60"><a href="#cb129-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-61"><a href="#cb129-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Obtain a subscriber</span></span>
<span id="cb129-62"><a href="#cb129-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> sub <span class="op">=</span> SHARED<span class="op">.</span>subscriber()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb129-63"><a href="#cb129-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-64"><a href="#cb129-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb129-65"><a href="#cb129-65" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for the next message from the subscriber</span></span>
<span id="cb129-66"><a href="#cb129-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> val <span class="op">=</span> sub<span class="op">.</span>next_message_pure()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb129-67"><a href="#cb129-67" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb129-68"><a href="#cb129-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Print the received value</span></span>
<span id="cb129-69"><a href="#cb129-69" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> val)<span class="op">;</span></span>
<span id="cb129-70"><a href="#cb129-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb129-71"><a href="#cb129-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Explanation:</p>
<ol type="1">
<li>Global Variable Setup:
<ul>
<li>A global <code>SHARED</code> <code>PubSubChannel</code> is defined
with a capacity of <code>2</code>, supporting <code>2</code> publishers
and <code>2</code> subscribers.</li>
</ul></li>
<li>Asynchronous Tasks (<code>async_task_one</code> and
<code>async_task_two</code>):
<ul>
<li>Both tasks obtain their own publishers (<code>pub1</code> and
<code>pub2</code>).</li>
<li><code>async_task_one</code> publishes the value <code>1</code> every
0.5 seconds.</li>
<li><code>async_task_two</code> publishes the value <code>2</code> every
1 second.</li>
</ul></li>
<li>Main Function:
<ul>
<li>Initializes peripherals and the Embassy executor.</li>
<li>Spawns both asynchronous tasks.</li>
<li>Obtains a subscriber (<code>sub</code>) to receive messages.</li>
<li>In the main loop, it waits for messages from the subscriber and
prints them as they are received.</li>
</ul></li>
</ol>
<p>Behavior: - Each published message is broadcasted to all subscribers.
- In this example, the main task acts as a single subscriber receiving
messages from both publishers. - If multiple subscribers were present,
each would receive every message published to the channel. - If a
subscriber misses a message because it was busy or not ready, it will
receive an error signaling that occurrence.</p>
<p>Important Considerations: - Message Delivery: Every message published
is delivered to all active subscribers. - Error Handling: Subscribers
may receive errors if they miss messages due to buffer overflows or
other issues. - Capacity Management: The channel’s capacity should be
chosen based on the expected message rate and subscriber readiness to
prevent message loss.</p>
</body>
</html>
